./src/routes/static.rs
```
use crate::Config;
use axum::{routing::get_service, Router};
use tower_http::services::ServeDir;

pub fn routes() -> Router {
    let config = Config::from_env();
    Router::new().nest_service("/static", get_service(ServeDir::new(config.static_path)))
}
```
./src/routes/mod.rs
```
use axum::Router;

pub mod macros;
pub mod r#static;
pub mod v0;

pub fn routes() -> Router {
    let routes_v0 = v0::routes();
    let route_static = r#static::routes();

    routes_v0.merge(route_static)
}
```
./src/routes/macros.rs
```
#[macro_export]
macro_rules! register_routes {
    ($router:expr, $($path:expr => $handler:expr),* $(,)?) => {
        $router
            $(.route($path, axum::routing::get($handler)))*
    };
}
```
./src/routes/v0/mod.rs
```
use axum::Router;
use utoipa::OpenApi;
use utoipa_swagger_ui::SwaggerUi;

pub mod endpoints;
pub mod info;
pub mod post;
pub mod user;

pub fn routes() -> Router {
    let routes_info = info::routes();
    let routes_post = post::routes();
    let route_user = user::routes();
    let route_openapi =
        SwaggerUi::new("/swagger-ui").url("/api-docs/openapi.json", ApiDoc::merge_docs());

    routes_post
        .merge(routes_info)
        .merge(route_user)
        .merge(route_openapi)
}

#[derive(OpenApi)]
#[openapi()]
pub struct ApiDoc;

impl ApiDoc {
    pub fn merge_docs() -> utoipa::openapi::OpenApi {
        let mut combined = post::PostApiDoc::merge_docs();
        combined.merge(info::InfoApiDoc::openapi());
        combined.merge(user::UserApiDoc::merge_docs());
        combined
    }
}
```
./src/routes/v0/endpoints.rs
```
use const_format::concatcp;

// Version routes
const VERSION_ROUTE: &str = "/v0";

// Info routes
pub const INFO_ROUTE: &str = concatcp!(VERSION_ROUTE, "/info");

// User routes
const USER_PREFIX: &str = concatcp!(VERSION_ROUTE, "/user");
pub const USER_ROUTE: &str = concatcp!(USER_PREFIX, "/:user_id");
pub const RELATIONSHIP_ROUTE: &str = concatcp!(USER_ROUTE, "/relationship/:viewer_id");
pub const USER_COUNTS_ROUTE: &str = concatcp!(USER_ROUTE, "/counts");
pub const USER_DETAILS_ROUTE: &str = concatcp!(USER_ROUTE, "/details");
pub const USER_TAGS_ROUTE: &str = concatcp!(USER_ROUTE, "/tags");
pub const USER_FOLLOWERS_ROUTE: &str = concatcp!(USER_ROUTE, "/followers");
pub const USER_FOLLOWING_ROUTE: &str = concatcp!(USER_ROUTE, "/following");

// Post routes
const POST_PREFIX: &str = concatcp!(VERSION_ROUTE, "/post");
pub const POST_ROUTE: &str = concatcp!(POST_PREFIX, "/:author_id/:post_id");
pub const POST_RELATIONSHIPS_ROUTE: &str = concatcp!(POST_ROUTE, "/relationships");
pub const POST_BOOKMARK_ROUTE: &str = concatcp!(POST_ROUTE, "/bookmark");
pub const POST_COUNTS_ROUTE: &str = concatcp!(POST_ROUTE, "/counts");
pub const POST_DETAILS_ROUTE: &str = concatcp!(POST_ROUTE, "/details");
pub const POST_TAGS_ROUTE: &str = concatcp!(POST_ROUTE, "/tags");
```
./src/routes/v0/post/mod.rs
```
use crate::register_routes;
use crate::routes::v0::endpoints;
use axum::Router;
use utoipa::OpenApi;

mod bookmark;
mod counts;
mod details;
mod view;

pub fn routes() -> Router {
    register_routes!(Router::new(),
        endpoints::POST_ROUTE => view::post_view_handler,
        endpoints::POST_DETAILS_ROUTE => details::post_details_handler,
        endpoints::POST_COUNTS_ROUTE => counts::post_counts_handler,
        endpoints::POST_BOOKMARK_ROUTE => bookmark::post_bookmark_handler,
    )
}

#[derive(OpenApi)]
#[openapi()]
pub struct PostApiDoc;

impl PostApiDoc {
    pub fn merge_docs() -> utoipa::openapi::OpenApi {
        let mut combined = view::PostViewApiDoc::openapi();
        combined.merge(counts::PostCountsApiDoc::openapi());
        combined.merge(bookmark::BookmarkApiDoc::openapi());
        combined.merge(details::PostDetailsApiDoc::openapi());
        combined
    }
}
```
./src/routes/v0/post/bookmark.rs
```
use crate::models::post::Bookmark;
use crate::routes::v0::endpoints::POST_BOOKMARK_ROUTE;
use crate::{Error, Result};
use axum::extract::{Path, Query};
use axum::Json;
use log::info;
use serde::Deserialize;
use utoipa::OpenApi;

#[derive(Deserialize)]
pub struct PostQuery {
    viewer_id: Option<String>,
}

#[utoipa::path(
    get,
    path = POST_BOOKMARK_ROUTE,
    tag = "Post Bookmark",
    params(
        ("author_id" = String, Path, description = "Author Pubky ID"),
        ("post_id" = String, Path, description = "Post Crockford32 ID"),
        ("viewer_id" = Option<String>, Query, description = "Viewer Pubky ID")
    ),
    responses(
        (status = 200, description = "Post Bookmark", body = Bookmark),
        (status = 404, description = "Post not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn post_bookmark_handler(
    Path((author_id, post_id)): Path<(String, String)>,
    Query(query): Query<PostQuery>,
) -> Result<Json<Bookmark>> {
    info!(
        "GET {POST_BOOKMARK_ROUTE} author_id:{}, post_id:{}, viewer_id:{}",
        author_id,
        post_id,
        query.viewer_id.clone().unwrap_or_default()
    );

    match Bookmark::get_by_id(&author_id, &post_id, query.viewer_id.as_deref()).await {
        Ok(Some(post)) => Ok(Json(post)),
        Ok(None) => Err(Error::PostNotFound { author_id, post_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(paths(post_bookmark_handler), components(schemas(Bookmark)))]
pub struct BookmarkApiDoc;
```
./src/routes/v0/post/details.rs
```
use crate::models::post::PostDetails;
use crate::routes::v0::endpoints::POST_DETAILS_ROUTE;
use crate::{Error, Result};
use axum::extract::Path;
use axum::Json;
use log::info;
use utoipa::OpenApi;

#[utoipa::path(
    get,
    path = POST_DETAILS_ROUTE,
    tag = "Post Details",
    params(
        ("author_id" = String, Path, description = "Author Pubky ID"),
        ("post_id" = String, Path, description = "Post Crockford32 ID")
    ),
    responses(
        (status = 200, description = "Post Details", body = PostDetails),
        (status = 404, description = "Post not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn post_details_handler(
    Path((author_id, post_id)): Path<(String, String)>,
) -> Result<Json<PostDetails>> {
    info!(
        "GET {POST_DETAILS_ROUTE} author_id:{}, post_id:{}",
        author_id, post_id
    );

    match PostDetails::get_by_id(&author_id, &post_id).await {
        Ok(Some(post)) => Ok(Json(post)),
        Ok(None) => Err(Error::PostNotFound { author_id, post_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(paths(post_details_handler), components(schemas(PostDetails)))]
pub struct PostDetailsApiDoc;
```
./src/routes/v0/post/counts.rs
```
use crate::models::post::PostCounts;
use crate::routes::v0::endpoints::POST_COUNTS_ROUTE;
use crate::{Error, Result};
use axum::extract::Path;
use axum::Json;
use log::info;
use utoipa::OpenApi;

#[utoipa::path(
    get,
    path = POST_COUNTS_ROUTE,
    tag = "Post Counts",
    params(
        ("author_id" = String, Path, description = "Author Pubky ID"),
        ("post_id" = String, Path, description = "Post Crockford32 ID")
    ),
    responses(
        (status = 200, description = "Post Counts", body = PostCounts),
        (status = 404, description = "Post not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn post_counts_handler(
    Path((author_id, post_id)): Path<(String, String)>,
) -> Result<Json<PostCounts>> {
    info!(
        "GET {POST_COUNTS_ROUTE} author_id:{}, post_id:{}",
        author_id, post_id
    );

    match PostCounts::get_by_id(&author_id, &post_id).await {
        Ok(Some(post)) => Ok(Json(post)),
        Ok(None) => Err(Error::PostNotFound { author_id, post_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(paths(post_counts_handler), components(schemas(PostCounts)))]
pub struct PostCountsApiDoc;
```
./src/routes/v0/post/view.rs
```
use crate::models::post::{PostRelationships, PostView};
use crate::routes::v0::endpoints::POST_ROUTE;
use crate::{Error, Result};
use axum::extract::{Path, Query};
use axum::Json;
use log::info;
use serde::Deserialize;
use utoipa::OpenApi;

#[derive(Deserialize)]
pub struct PostQuery {
    viewer_id: Option<String>,
}

#[utoipa::path(
    get,
    path = POST_ROUTE,
    tag = "Post",
    params(
        ("author_id" = String, Path, description = "Author Pubky ID"),
        ("post_id" = String, Path, description = "Post Crockford32 ID"),
        ("viewer_id" = Option<String>, Query, description = "Viewer Pubky ID")
    ),
    responses(
        (status = 200, description = "Post", body = PostView),
        (status = 404, description = "Post not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn post_view_handler(
    Path((author_id, post_id)): Path<(String, String)>,
    Query(query): Query<PostQuery>,
) -> Result<Json<PostView>> {
    info!(
        "GET {POST_ROUTE} author_id:{}, post_id:{}, viewer_id:{}",
        author_id,
        post_id,
        query.viewer_id.clone().unwrap_or_default()
    );

    match PostView::get_by_id(&author_id, &post_id, query.viewer_id.as_deref()).await {
        Ok(Some(post)) => Ok(Json(post)),
        Ok(None) => Err(Error::PostNotFound { author_id, post_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(
    paths(post_view_handler),
    components(schemas(PostView, PostRelationships))
)]
pub struct PostViewApiDoc;
```
./src/routes/v0/user/follows.rs
```
use crate::models::user::{Follows, FollowsVariant};
use crate::routes::v0::endpoints::{USER_FOLLOWERS_ROUTE, USER_FOLLOWING_ROUTE};
use crate::{Error, Result};
use axum::extract::Path;
use axum::Json;
use log::info;
use utoipa::OpenApi;

#[utoipa::path(
    get,
    path = USER_FOLLOWERS_ROUTE,
    tag = "User Followers List",
    params(
        ("user_id" = String, Path, description = "User Pubky ID")
    ),
    responses(
        (status = 200, description = "User followers list", body = Follows),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn user_followers_handler(Path(user_id): Path<String>) -> Result<Json<Follows>> {
    info!("GET {USER_FOLLOWERS_ROUTE} user_id:{}", user_id);

    match Follows::get_by_id(&user_id, FollowsVariant::Followers).await {
        Ok(Some(followers)) => Ok(Json(followers)),
        Ok(None) => Err(Error::UserNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[utoipa::path(
    get,
    path = USER_FOLLOWING_ROUTE,
    tag = "User Following List",
    params(
        ("user_id" = String, Path, description = "User Pubky ID")
    ),
    responses(
        (status = 200, description = "User following list", body = Follows),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn user_following_handler(Path(user_id): Path<String>) -> Result<Json<Follows>> {
    info!("GET {USER_FOLLOWING_ROUTE} user_id:{}", user_id);

    match Follows::get_by_id(&user_id, FollowsVariant::Following).await {
        Ok(Some(following)) => Ok(Json(following)),
        Ok(None) => Err(Error::UserNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(
    paths(user_followers_handler, user_following_handler),
    components(schemas(Follows))
)]
pub struct UserFollowsApiDoc;
```
./src/routes/v0/user/relationship.rs
```
use crate::models::user::Relationship;
use crate::routes::v0::endpoints::RELATIONSHIP_ROUTE;
use crate::{Error, Result};
use axum::extract::Path;
use axum::Json;
use log::info;
use utoipa::OpenApi;

#[utoipa::path(
    get,
    path = RELATIONSHIP_ROUTE,
    tag = "User <> Viewer Relationship",
    params(
        ("user_id" = String, Path, description = "User Pubky ID"),
        ("viewer_id" = String, Path, description = "Viewer Pubky ID")
    ),
    responses(
        (status = 200, description = "User relationship", body = Relationship),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn user_relationship_handler(
    Path((user_id, viewer_id)): Path<(String, String)>,
) -> Result<Json<Relationship>> {
    info!(
        "GET {RELATIONSHIP_ROUTE} user_id:{}, viewer_id:{}",
        user_id, viewer_id
    );

    match Relationship::get_by_id(&user_id, Some(&viewer_id)).await {
        Ok(Some(relationship)) => Ok(Json(relationship)),
        Ok(None) => Err(Error::UserNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(paths(user_relationship_handler), components(schemas(Relationship)))]
pub struct RelationshipApiDoc;
```
./src/routes/v0/user/tags.rs
```
use crate::models::user::{ProfileTag, UserTags};
use crate::routes::v0::endpoints::USER_TAGS_ROUTE;
use crate::{Error, Result};
use axum::extract::Path;
use axum::Json;
use log::info;
use utoipa::OpenApi;

#[utoipa::path(
    get,
    path = USER_TAGS_ROUTE,
    tag = "User Tags",
    params(
        ("user_id" = String, Path, description = "User Pubky ID")
    ),
    responses(
        (status = 200, description = "User tags", body = UserTags),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn user_tags_handler(Path(user_id): Path<String>) -> Result<Json<UserTags>> {
    info!("GET {USER_TAGS_ROUTE} user_id:{}", user_id);

    match UserTags::get_by_id(&user_id).await {
        Ok(Some(tags)) => Ok(Json(tags)),
        Ok(None) => Err(Error::UserNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(paths(user_tags_handler), components(schemas(UserTags, ProfileTag)))]
pub struct UserTagsApiDoc;
```
./src/routes/v0/user/mod.rs
```
use crate::register_routes;
use crate::routes::v0::endpoints;
use axum::Router;
use utoipa::OpenApi;

mod counts;
mod details;
mod follows;
mod relationship;
mod tags;
mod view;

pub fn routes() -> Router {
    register_routes!(Router::new(),
        endpoints::USER_ROUTE => view::user_view_handler,
        endpoints::USER_DETAILS_ROUTE => details::user_details_handler,
        endpoints::RELATIONSHIP_ROUTE => relationship::user_relationship_handler,
        endpoints::USER_TAGS_ROUTE => tags::user_tags_handler,
        endpoints::USER_COUNTS_ROUTE => counts::user_counts_handler,
        endpoints::USER_FOLLOWERS_ROUTE => follows::user_followers_handler,
        endpoints::USER_FOLLOWING_ROUTE => follows::user_following_handler,
    )
}

#[derive(OpenApi)]
#[openapi()]
pub struct UserApiDoc;

impl UserApiDoc {
    pub fn merge_docs() -> utoipa::openapi::OpenApi {
        let mut combined = view::UserViewApiDoc::openapi();
        combined.merge(counts::UserCountsApiDoc::openapi());
        combined.merge(details::UserDetailsApiDoc::openapi());
        combined.merge(relationship::RelationshipApiDoc::openapi());
        combined.merge(tags::UserTagsApiDoc::openapi());
        combined.merge(follows::UserFollowsApiDoc::openapi());
        combined
    }
}
```
./src/routes/v0/user/details.rs
```
use crate::models::user::{UserDetails, UserLink};
use crate::routes::v0::endpoints::USER_DETAILS_ROUTE;
use crate::{Error, Result};
use axum::extract::Path;
use axum::Json;
use log::info;
use utoipa::OpenApi;

#[utoipa::path(
    get,
    path = USER_DETAILS_ROUTE,
    tag = "User Details",
    params(
        ("user_id" = String, Path, description = "User Pubky ID")
    ),
    responses(
        (status = 200, description = "User details", body = UserDetails),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn user_details_handler(Path(user_id): Path<String>) -> Result<Json<UserDetails>> {
    info!("GET {USER_DETAILS_ROUTE} user_id:{}", user_id);

    match UserDetails::get_by_id(&user_id).await {
        Ok(Some(details)) => Ok(Json(details)),
        Ok(None) => Err(Error::UserNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(
    paths(user_details_handler),
    components(schemas(UserDetails, UserLink))
)]
pub struct UserDetailsApiDoc;
```
./src/routes/v0/user/counts.rs
```
use crate::models::user::UserCounts;
use crate::routes::v0::endpoints::USER_COUNTS_ROUTE;
use crate::{Error, Result};
use axum::extract::Path;
use axum::Json;
use log::info;
use utoipa::OpenApi;

#[utoipa::path(
    get,
    path = USER_COUNTS_ROUTE,
    tag = "User Counts",
    params(
        ("user_id" = String, Path, description = "User Pubky ID")
    ),
    responses(
        (status = 200, description = "User counts", body = UserCounts),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn user_counts_handler(Path(user_id): Path<String>) -> Result<Json<UserCounts>> {
    info!("GET {USER_COUNTS_ROUTE} user_id:{}", user_id);

    match UserCounts::get_by_id(&user_id).await {
        Ok(Some(counts)) => Ok(Json(counts)),
        Ok(None) => Err(Error::UserNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(paths(user_counts_handler), components(schemas(UserCounts)))]
pub struct UserCountsApiDoc;
```
./src/routes/v0/user/view.rs
```
use crate::models::user::UserView;
use crate::routes::v0::endpoints::USER_ROUTE;
use crate::{Error, Result};
use axum::extract::{Path, Query};
use axum::Json;
use log::info;
use serde::Deserialize;
use utoipa::OpenApi;

#[derive(Deserialize)]
pub struct ProfileQuery {
    viewer_id: Option<String>,
}

#[utoipa::path(
    get,
    path = USER_ROUTE,
    tag = "User Profile",
    params(
        ("user_id" = String, Path, description = "User Pubky ID"),
        ("viewer_id" = Option<String>, Query, description = "Viewer Pubky ID")
    ),
    responses(
        (status = 200, description = "User Profile", body = UserView),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn user_view_handler(
    Path(user_id): Path<String>,
    Query(query): Query<ProfileQuery>,
) -> Result<Json<UserView>> {
    info!(
        "GET {USER_ROUTE} user_id:{}, viewer_id:{:?}",
        user_id, query.viewer_id
    );

    match UserView::get_by_id(&user_id, query.viewer_id.as_deref()).await {
        Ok(Some(user)) => Ok(Json(user)),
        Ok(None) => Err(Error::UserNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(paths(user_view_handler), components(schemas(UserView)))]
pub struct UserViewApiDoc;
```
./src/routes/v0/info.rs
```
use super::endpoints::INFO_ROUTE;
use crate::models::info::ServerInfo;
use crate::register_routes;
use axum::response::IntoResponse;
use axum::{Json, Router};
use utoipa::OpenApi;

#[utoipa::path(
    get,
    path = INFO_ROUTE,
    tag = "Service Info",
    responses(
        (status = 200, description = "Server info", body = ServerInfo)
    )
)]
pub async fn info_handler() -> impl IntoResponse {
    let info = ServerInfo::new();
    Json(info)
}

pub fn routes() -> Router {
    register_routes!(Router::new(), super::endpoints::INFO_ROUTE => info_handler)
}

#[derive(OpenApi)]
#[openapi(paths(info_handler), components(schemas(ServerInfo)))]
pub struct InfoApiDoc;
```
./src/watcher.rs
```
// TODO: Research if that one is the best approach
// Maybe here we can create an POST endpoint that fakes the event stream
// After with mpsc (Multiple Producer Single Consumer) broadcast the event
// to all consumers. In our case, graph and kv
fn main() {
    println!("Hello, world! This is where the homeserver(s) watcher will be in the future.");
}
```
./src/db/kv/mod.rs
```
pub mod index;
pub mod traits;
```
./src/db/kv/traits.rs
```
use super::index::{self, RangeReturnType};
use async_trait::async_trait;
use serde::{de::DeserializeOwned, Serialize};
use std::error::Error;

/// A trait for operations involving Redis storage. Implement this trait for types that need to be stored
/// and retrieved from Redis with serialization and deserialization capabilities.
#[async_trait]
pub trait RedisOps: Serialize + DeserializeOwned + Send + Sync {
    /// Provides a prefix string for the Redis key.
    ///
    /// This method should return a prefix string that helps namespace the keys in Redis,
    /// preventing key collisions. The prefix is typically derived from the struct name.
    ///
    /// # Returns
    ///
    /// A `String` representing the prefix for Redis keys.
    async fn prefix() -> String {
        let type_name = std::any::type_name::<Self>();
        let struct_name = type_name.split("::").last().unwrap_or_default();
        String::from(struct_name)
    }

    async fn try_from_bool_index(
        key_parts: &[&str],
    ) -> Result<Option<bool>, Box<dyn Error + Send + Sync>> {
        let prefix = Self::prefix().await;
        let key = key_parts.join(":");
        index::get_bool(&prefix, &key).await
    }

    /// Sets the data in Redis using the provided key parts.
    ///
    /// This method serializes the data and stores it in Redis under the key generated
    /// from the provided `key_parts`. It can also set an expiration time for the key if required.
    ///
    /// # Arguments
    ///
    /// * `key_parts` - A slice of string slices that represent the parts used to form the key under which the value is stored.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails, such as if the Redis connection is unavailable.
    async fn set_index(&self, key_parts: &[&str]) -> Result<(), Box<dyn Error + Send + Sync>> {
        index::set(
            &Self::prefix().await,
            &key_parts.join(":"),
            self,
            None,
            None,
        )
        .await
    }

    /// Sets multiple indexes in Redis using the provided list of key parts for each value in the collection.
    ///
    /// This method serializes each item in the collection and stores it in Redis under the keys generated
    /// from the provided `key_parts_list`. It supports setting multiple key-value pairs efficiently.
    ///
    /// # Arguments
    ///
    /// * `key_parts_list` - A slice of slices, where each inner slice contains string slices representing
    ///   the parts used to form the key under which the corresponding value in the collection is stored.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails, such as if the Redis connection is unavailable or
    /// if there is an issue with serialization.
    async fn set_multiple_indexes<T>(
        &self,
        key_parts_list: &[&[&str]],
    ) -> Result<(), Box<dyn Error + Send + Sync>>
    where
        Self: AsRef<[T]>,           // Assuming Self can be dereferenced into a slice of T
        T: Serialize + Send + Sync, // The items in the collection must be serializable
    {
        let collection = self.as_ref();

        let mut data = Vec::with_capacity(key_parts_list.len());
        for (i, key_parts) in key_parts_list.iter().enumerate() {
            let key = key_parts.join(":");
            data.push((key, &collection[i]));
        }

        index::set_multiple(&Self::prefix().await, &data).await
    }

    /// Retrieves data from Redis using the provided key parts.
    ///
    /// This method deserializes the data stored under the key generated from the provided `key_parts` in Redis.
    /// If the key is not found, it returns `None`.
    ///
    /// # Arguments
    ///
    /// * `key_parts` - A slice of string slices that represent the parts used to form the key under which the value is stored.
    ///
    /// # Returns
    ///
    /// An `Option<Self>` containing the deserialized data if found, or `None` if the key does not exist.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails, such as if the Redis connection is unavailable.
    async fn try_from_index(
        key_parts: &[&str],
    ) -> Result<Option<Self>, Box<dyn Error + Send + Sync>> {
        index::get(&Self::prefix().await, &key_parts.join(":"), None).await
    }

    /// TODO: THIS IS PROB NOT OK, NOT USEFUL AS IS
    /// Retrieves a range of data from Redis using a pattern to match keys, with optional pagination.
    ///
    /// This method fetches and deserializes data stored under keys matching the provided `pattern`.
    /// It supports pagination through the `skip` and `limit` parameters.
    ///
    /// # Arguments
    ///
    /// * `pattern` - An optional string slice representing the pattern to match keys. If not provided,
    ///   defaults to "*" which matches all keys under the prefix.
    /// * `skip` - An optional number of keys to skip (useful for pagination).
    /// * `limit` - An optional number of keys to return (useful for pagination).
    ///
    /// # Returns
    ///
    /// Returns a vector of deserialized values if they exist, or an empty vector if no matching keys are found.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails, such as if the Redis connection is unavailable or
    /// if there is an issue with deserialization.
    async fn try_from_index_range(
        pattern: Option<&str>,
        skip: Option<usize>,
        limit: Option<usize>,
    ) -> Result<Option<Vec<Self>>, Box<dyn Error + Send + Sync>>
    where
        Self: Sized,
    {
        let values = index::get_range::<Self>(&Self::prefix().await, pattern, skip, limit).await?;

        Ok(Some(values))
    }

    /// TODO: THIS IS PROB NOT OK, NOT USEFUL AS IS
    /// Retrieves a range of boolean values from Redis using a pattern to match keys, with optional pagination.
    ///
    /// This method fetches boolean values stored under keys matching the provided `pattern`.
    /// It supports pagination through the `skip` and `limit` parameters.
    ///
    /// # Arguments
    ///
    /// * `pattern` - An optional string slice representing the pattern to match keys. If not provided,
    ///   defaults to "*" which matches all keys under the prefix.
    /// * `skip` - An optional number of keys to skip (useful for pagination).
    /// * `limit` - An optional number of keys to return (useful for pagination).
    ///
    /// # Returns
    ///
    /// Returns a vector of boolean values if they exist, or an empty vector if no matching keys are found.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails, such as if the Redis connection is unavailable or
    /// if there is an issue with retrieving the data.
    async fn try_from_bool_index_range(
        pattern: Option<&str>,
        skip: Option<usize>,
        limit: Option<usize>,
    ) -> Result<Option<Vec<bool>>, Box<dyn Error + Send + Sync>> {
        let (_, values) = index::get_bool_range(
            &Self::prefix().await,
            pattern,
            skip,
            limit,
            RangeReturnType::Values,
        )
        .await?;

        // If values are found, return them; otherwise, return an empty vector.
        Ok(values)
    }
}
```
./src/db/kv/index/set_multiple.rs
```
use crate::db::connectors::redis::get_redis_conn;
use serde::Serialize;
use std::error::Error;

/// Sets a list of keys and their corresponding values in Redis in a single operation.
///
/// This function handles both JSON and boolean values, using RedisJSON for JSON data and storing booleans
/// as integers. It uses multiple commands in a single request to set key-value pairs efficiently.
/// Each value must implement the `Serialize` trait for JSON or be a boolean.
///
/// # Arguments
///
/// * `prefix` - A string slice representing the prefix for the Redis keys.
/// * `data` - A slice of tuples where each tuple contains a key as a string slice and a value that implements `Serialize`.
///
/// # Returns
///
/// Returns a `Result` indicating success or an error if the operation fails.
///
/// # Errors
///
/// This function will return an error if there are issues connecting to Redis, or if serialization of the values fails.
///
/// # Examples
///
/// ```ignore
/// use serde::Serialize;
///
/// #[derive(Serialize)]
/// struct MyValue {
///     field1: String,
///     field2: i32,
/// }
///
/// let data = vec![
///     ("key1", MyValue { field1: "value1".to_string(), field2: 10 }),
///     ("key2", MyValue { field1: "value2".to_string(), field2: 20 }),
///     ("key3", true), // boolean value
/// ];
///
/// set_multiple::<MyValue>("prefix:", &data).await?;
/// ```
///
/// This example sets multiple key-value pairs with a common prefix in Redis.
pub async fn set_multiple<T: Serialize>(
    prefix: &str,
    data: &[(impl AsRef<str>, T)],
) -> Result<(), Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;

    // Create a pipeline-like command sequence
    let mut cmd = redis::pipe();

    for (key, value) in data {
        let full_key = format!("{}:{}", prefix, key.as_ref());

        // Check if the value is boolean
        match serde_json::to_value(value)? {
            serde_json::Value::Bool(boolean_value) => {
                let int_value = if boolean_value { 1 } else { 0 };
                cmd.set(&full_key, int_value);
            }
            _ => {
                // Handle other values as JSON
                cmd.json_set(&full_key, "$", value)?;
            }
        }
    }

    cmd.query_async(&mut redis_conn).await?;
    Ok(())
}
```
./src/db/kv/index/set.rs
```
use crate::db::connectors::redis::get_redis_conn;
use log::debug;
use redis::{AsyncCommands, JsonAsyncCommands};
use serde::Serialize;
use std::error::Error;

/// Sets a value in Redis, supporting both JSON objects and boolean values.
///
/// This function stores JSON objects using RedisJSON and booleans as integers (0 or 1).
/// An optional expiration time can be set for both types.
///
/// # Arguments
///
/// * `prefix` - A string slice representing the prefix for the Redis key.
/// * `key` - A string slice representing the key under which the value is stored.
/// * `value` - A reference to the value to be stored. If the value is a boolean, it will be stored as 0 or 1. For other types, it must implement `Serialize`.
/// * `path` - An optional string slice representing the JSON path where the value should be set for JSON objects. Defaults to the root path "$".
/// * `expiration` - An optional expiration time in seconds. If provided, the key will expire after this duration.
///
/// # Errors
///
/// Returns an error if the operation fails.
pub async fn set<T: Serialize + Send + Sync>(
    prefix: &str,
    key: &str,
    value: &T,
    path: Option<&str>,
    expiration: Option<i64>,
) -> Result<(), Box<dyn Error + Send + Sync>> {
    let index_key = format!("{}:{}", prefix, key);

    match serde_json::to_value(value)? {
        serde_json::Value::Bool(boolean_value) => {
            set_boolean(&index_key, boolean_value, expiration).await?;
        }
        _ => {
            set_json(&index_key, value, path, expiration).await?;
        }
    }

    debug!(
        "Set key: {} with optional expiration: {:?}",
        index_key, expiration
    );
    Ok(())
}

async fn set_boolean(
    key: &str,
    value: bool,
    expiration: Option<i64>,
) -> Result<(), Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;

    let int_value = if value { 1 } else { 0 };
    if let Some(exp) = expiration {
        redis_conn.set_ex(key, int_value, exp as u64).await?;
    } else {
        redis_conn.set(key, int_value).await?;
    }
    Ok(())
}

async fn set_json<T: Serialize + Send + Sync>(
    key: &str,
    value: &T,
    path: Option<&str>,
    expiration: Option<i64>,
) -> Result<(), Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;

    let json_path = path.unwrap_or("$");
    redis_conn.json_set(key, json_path, value).await?;
    if let Some(exp) = expiration {
        redis_conn.expire(key, exp).await?;
    }
    Ok(())
}
```
./src/db/kv/index/get_bool.rs
```
use crate::db::connectors::redis::get_redis_conn;
use log::debug;
use redis::AsyncCommands;
use std::error::Error;

/// Retrieves a boolean value from Redis.
///
/// # Arguments
///
/// * `prefix` - A string slice that represents the prefix for the Redis key.
/// * `key` - A string slice that represents the key under which the value is stored.
///
/// # Returns
///
/// Returns an `Option` containing the retrieved boolean value if it exists, or `None` if it does not.
///
/// # Errors
///
/// Returns an error if the operation fails.
pub async fn get_bool(
    prefix: &str,
    key: &str,
) -> Result<Option<bool>, Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;
    let index_key = format!("{}:{}", prefix, key);

    if let Ok(indexed_value) = redis_conn.get::<_, i32>(&index_key).await {
        debug!(
            "Restored boolean key: {} with value: {}",
            index_key, indexed_value
        );
        let value = match indexed_value {
            1 => true,
            0 => false,
            _ => return Ok(None), // Invalid value in Redis
        };
        return Ok(Some(value));
    }

    Ok(None)
}
```
./src/db/kv/index/mod.rs
```
mod get;
mod get_bool;
mod get_bool_range;
mod get_range;
mod set;
mod set_multiple;

pub use get::get;
pub use get_bool::get_bool;
pub use get_bool_range::{get_bool_range, RangeReturnType};
pub use get_range::get_range;
pub use set::set;
pub use set_multiple::set_multiple;
```
./src/db/kv/index/get_bool_range.rs
```
use crate::db::connectors::redis::get_redis_conn;
use log::{debug, error};
use redis::Commands;
use redis::{RedisResult, Value};
use std::error::Error;

#[derive(PartialEq)]
pub enum RangeReturnType {
    #[allow(dead_code)]
    Keys,
    Values,
    #[allow(dead_code)]
    Both,
}

/// Retrieves a range of boolean values from Redis based on a pattern, with optional skip and limit for pagination.
///
/// # Arguments
///
/// * `prefix` - A string slice that represents the prefix for the Redis key.
/// * `pattern` - An optional string slice representing the pattern to match keys.
/// * `skip` - An optional number of keys to skip (for pagination).
/// * `limit` - An optional number of keys to return (for pagination).
///
/// # Returns
///
/// Returns a vector of boolean values if they exist, or an empty vector if no matching keys are found.
///
/// # Errors
///
/// Returns an error if the operation fails.
pub async fn get_bool_range(
    prefix: &str,
    pattern: Option<&str>,
    skip: Option<usize>,
    limit: Option<usize>,
    return_type: RangeReturnType,
) -> Result<(Option<Vec<String>>, Option<Vec<bool>>), Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;
    let limit = limit.unwrap_or(100);
    let skip = skip.unwrap_or(0);
    let full_pattern = format!("{}:{}", prefix, pattern.unwrap_or("*"));

    let mut result_keys = Vec::with_capacity(limit);
    let mut cursor = "0".to_string();
    let count = 1000;
    let mut skipped = 0;

    loop {
        let result: (String, Vec<String>) = redis::cmd("SCAN")
            .arg(cursor)
            .arg("MATCH")
            .arg(&full_pattern)
            .arg("COUNT")
            .arg(count)
            .query_async(&mut redis_conn)
            .await?;

        let (new_cursor, keys) = result;

        for key in keys {
            if skipped < skip {
                skipped += 1;
                continue;
            }
            result_keys.push(key);
            if result_keys.len() >= limit {
                break;
            }
        }

        if result_keys.len() >= limit || new_cursor == "0" {
            break;
        }

        cursor = new_cursor;
    }

    if return_type == RangeReturnType::Keys {
        debug!("Restored keys: {:?}", result_keys);
        return Ok((Some(result_keys), None));
    }

    Ok((None, None))

    // all_keys.sort();

    // let skip = skip.unwrap_or(0);
    // let limit = limit.unwrap_or(all_keys.len());

    // let selected_keys: Vec<String> = all_keys.into_iter().skip(skip).take(limit).collect();

    // let fetch_values = async {
    //     let redis_values: Vec<Option<i32>> = redis_conn.mget(&selected_keys).await?;
    //     Ok::<Vec<bool>, Box<dyn Error + Send + Sync>>(
    //         redis_values
    //             .into_iter()
    //             .flatten()
    //             .map(|val| val != 0)
    //             .collect(),
    //     )
    // };

    // let (keys, values) = match return_type {
    //     RangeReturnType::Keys => (Some(selected_keys.clone()), None),
    //     RangeReturnType::Values => {
    //         let values = fetch_values.await?;
    //         (None, Some(values))
    //     }
    //     RangeReturnType::Both => {
    //         let values = fetch_values.await?;
    //         (Some(selected_keys), Some(values))
    //     }
    // };

    // debug!("Restored keys: {:?} with values: {:?}", keys, values);
    // Ok((keys, values))
}

// #[cfg(test)]
// mod tests {
//     use super::*;
//     use crate::{db::kv::index::set_multiple, setup, Config};
//     use tokio;

//     #[tokio::test]
//     async fn test_get_bool_range() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
//         let config = Config::from_env();
//         setup(&config).await;

//         let data = vec![("bool1", true), ("bool2", false), ("bool3", true)];

//         // Set boolean values in Redis
//         set_multiple::<bool>("test:", &data).await?;

//         // Retrieve boolean values using `get_bool_range` with a specific pattern
//         let (_, values) = get_bool_range(
//             "test:",
//             Some("bool*"),
//             Some(0),
//             Some(10),
//             RangeReturnType::Values,
//         )
//         .await?;

//         // Ensure the returned result is not None
//         let result = values.ok_or("No values found")?;
//         assert_eq!(result.len(), data.len());

//         let expected_values: Vec<bool> = data.into_iter().map(|(_, v)| v).collect();
//         assert_eq!(result, expected_values);

//         Ok(())
//     }
// }
```
./src/db/kv/index/get_range.rs
```
use crate::db::connectors::redis::get_redis_conn;
use log::debug;
use redis::AsyncCommands;
use serde::de::DeserializeOwned;
use std::error::Error;

/// Retrieves a range of values from Redis based on a pattern, with optional skip and limit for pagination.
///
/// # Arguments
///
/// * `prefix` - A string slice that represents the prefix for the Redis key.
/// * `pattern` - An optional string slice representing the pattern to match keys.
/// * `skip` - An optional number of keys to skip (for pagination).
/// * `limit` - An optional number of keys to return (for pagination).
///
/// # Returns
///
/// Returns a vector of deserialized values if they exist, or an empty vector if no matching keys are found.
///
/// # Errors
///
/// Returns an error if the operation fails.
pub async fn get_range<T: DeserializeOwned + Send + Sync>(
    prefix: &str,
    pattern: Option<&str>,
    skip: Option<usize>,
    limit: Option<usize>,
) -> Result<Vec<T>, Box<dyn Error + Send + Sync>> {
    let pattern = pattern.unwrap_or("*");
    let mut redis_conn = get_redis_conn().await?;
    let mut iter = redis_conn
        .scan_match::<String, String>(format!("{}{}", prefix, pattern))
        .await?;

    let mut keys_to_get = vec![];
    while let Some(key) = iter.next_item().await {
        keys_to_get.push(key);
    }

    // Sort keys alphanumerically
    keys_to_get.sort();

    let skip = skip.unwrap_or(0);
    let limit = limit.unwrap_or(keys_to_get.len());

    // Drop the iterator to release the mutable borrow on redis_conn
    drop(iter);

    let selected_keys: Vec<String> = keys_to_get.into_iter().skip(skip).take(limit).collect();

    // Using a pipeline to get multiple JSON values
    let mut pipeline = redis::pipe();
    for key in &selected_keys {
        pipeline.cmd("JSON.GET").arg(key).arg("$");
    }

    let json_values: Vec<Option<String>> = pipeline.query_async(&mut redis_conn).await?;

    let mut results = Vec::with_capacity(json_values.len());
    for json_value in json_values.into_iter().flatten() {
        let mut deserialized_values: Vec<T> = serde_json::from_str(&json_value)?;
        if let Some(value) = deserialized_values.pop() {
            results.push(value);
        }
    }

    debug!("Restored keys: {:?}", selected_keys);
    Ok(results)
}

// #[cfg(test)]
// mod tests {
//     use super::*;
//     use crate::{db::kv::index::set_multiple::set_multiple, setup, Config};
//     use serde::{Deserialize, Serialize};
//     use tokio;

//     #[derive(Serialize, Deserialize, Debug, PartialEq)]
//     struct MyValue {
//         field1: String,
//         field2: i32,
//     }

//     #[tokio::test]
//     async fn test_get_range() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
//         let config = Config::from_env();
//         setup(&config).await;

//         let data = vec![
//             (
//                 "key1",
//                 MyValue {
//                     field1: "value1".to_string(),
//                     field2: 10,
//                 },
//             ),
//             (
//                 "key2",
//                 MyValue {
//                     field1: "value2".to_string(),
//                     field2: 20,
//                 },
//             ),
//             (
//                 "key3",
//                 MyValue {
//                     field1: "value3".to_string(),
//                     field2: 30,
//                 },
//             ),
//         ];

//         // Set values in Redis
//         set_multiple::<MyValue>("test:", &data).await?;

//         // Retrieve values using `get_range` with a specific pattern
//         let result = get_range::<MyValue>("test:", Some("key*"), Some(0), Some(10)).await?;
//         assert_eq!(result.len(), data.len());

//         let expected_values: Vec<MyValue> = data.into_iter().map(|(_, v)| v).collect();
//         assert_eq!(result, expected_values);

//         Ok(())
//     }
// }
```
./src/db/kv/index/get.rs
```
use crate::db::connectors::redis::get_redis_conn;
use log::debug;
use redis::JsonAsyncCommands;
use serde::de::DeserializeOwned;
use std::error::Error;

/// Retrieves a JSON value from Redis at a specified path.
///
/// # Arguments
///
/// * `prefix` - A string slice that represents the prefix for the Redis key.
/// * `key` - A string slice that represents the key under which the value is stored.
/// * `path` - An optional string slice representing the JSON path from which the value should be retrieved. Defaults to the root path "$".
///
/// # Returns
///
/// Returns an `Option` containing the retrieved value if it exists, or `None` if it does not.
///
/// # Errors
///
/// Returns an error if the operation fails.
pub async fn get<T: DeserializeOwned + Send + Sync>(
    prefix: &str,
    key: &str,
    path: Option<&str>,
) -> Result<Option<T>, Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;
    let index_key = format!("{}:{}", prefix, key);
    let json_path = path.unwrap_or("$").to_string(); // Ensure path is a String

    // Use RedisJSON commands to get the value from the specified path
    if let Ok(indexed_value) = redis_conn
        .json_get::<String, String, String>(index_key.clone(), json_path)
        .await
    {
        debug!("Restored key: {} with value: {}", index_key, indexed_value);
        let value: Vec<T> = serde_json::from_str(&indexed_value)?;
        return Ok(value.into_iter().next()); // Extract the first element from the Vec
    }

    Ok(None)
}
```
./src/db/connectors/neo4j.rs
```
use neo4rs::Graph;
use once_cell::sync::OnceCell;
use std::fmt;
use std::sync::Arc;
use tokio::sync::Mutex;

pub struct Neo4jConnector {
    pub graph: OnceCell<Arc<Mutex<Graph>>>,
}

impl Default for Neo4jConnector {
    fn default() -> Self {
        Self::new()
    }
}

impl Neo4jConnector {
    pub fn new() -> Self {
        Self {
            graph: OnceCell::new(),
        }
    }

    pub async fn connect(
        &self,
        uri: &str,
        user: &str,
        password: &str,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let graph = Graph::new(uri, user, password).await?;
        self.graph
            .set(Arc::new(Mutex::new(graph)))
            .map_err(|_| "Failed to set graph instance")?;
        Ok(())
    }

    pub async fn new_connection(
        uri: &str,
        user: &str,
        password: &str,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let neo4j_connector = Neo4jConnector::new();
        neo4j_connector.connect(uri, user, password).await?;
        Ok(neo4j_connector)
    }
}

impl fmt::Debug for Neo4jConnector {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Neo4jConnector")
            .field("graph", &"Graph instance")
            .finish()
    }
}

/// Helper to retrieve a Neo4j graph connection.
pub fn get_neo4j_graph() -> Result<Arc<Mutex<Graph>>, &'static str> {
    let neo4j_connector = NEO4J_CONNECTOR
        .get()
        .ok_or("Neo4jConnector not initialized")?;
    let graph = neo4j_connector
        .graph
        .get()
        .ok_or("Not connected to Neo4j")?;
    Ok(graph.clone())
}

pub static NEO4J_CONNECTOR: OnceCell<Neo4jConnector> = OnceCell::new();
```
./src/db/connectors/mod.rs
```
pub mod neo4j;
pub mod redis;
```
./src/db/connectors/redis.rs
```
use once_cell::sync::OnceCell;
use redis::aio::MultiplexedConnection;
use redis::Client;
use std::fmt;

pub struct RedisConnector {
    client: OnceCell<Client>,
}

impl Default for RedisConnector {
    fn default() -> Self {
        Self::new()
    }
}

impl RedisConnector {
    pub fn new() -> Self {
        Self {
            client: OnceCell::new(),
        }
    }

    pub async fn connect(&self, uri: &str) -> Result<(), Box<dyn std::error::Error>> {
        let client = Client::open(uri)?;
        self.client
            .set(client)
            .map_err(|_| "Failed to set Redis client instance")?;
        Ok(())
    }

    pub async fn new_connection(uri: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let redis_connector = RedisConnector::new();
        redis_connector.connect(uri).await?;
        Ok(redis_connector)
    }

    pub fn client(&self) -> &Client {
        self.client.get().expect("Not connected to Redis")
    }
}

impl fmt::Debug for RedisConnector {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("RedisConnector")
            .field("client", &"Redis client instance")
            .finish()
    }
}

/// Retrieves a Redis connection.
pub async fn get_redis_conn(
) -> Result<MultiplexedConnection, Box<dyn std::error::Error + Send + Sync>> {
    let redis_client = REDIS_CONNECTOR
        .get()
        .ok_or("RedisConnector not initialized")?
        .client();
    let redis_conn = redis_client.get_multiplexed_async_connection().await?;
    Ok(redis_conn)
}

pub static REDIS_CONNECTOR: OnceCell<RedisConnector> = OnceCell::new();
```
./src/db/mod.rs
```
pub mod connectors;
pub mod graph;
pub mod kv;
```
./src/db/graph/mod.rs
```
pub mod queries;
```
./src/db/graph/queries.rs
```
use crate::db::connectors::neo4j::get_neo4j_graph;
use neo4rs::{query, Query};

// Set graph constraints if they do not already exist
pub async fn setup_graph() -> Result<(), Box<dyn std::error::Error>> {
    let constraints = [
        "CREATE CONSTRAINT uniqueUserId IF NOT EXISTS FOR (u:User) REQUIRE u.id IS UNIQUE",
        "CREATE CONSTRAINT uniquePostId IF NOT EXISTS FOR (p:Post) REQUIRE p.id IS UNIQUE",
    ];

    let indexes = [
        "CREATE INDEX userIdIndex IF NOT EXISTS FOR (u:User) ON (u.id)",
        "CREATE INDEX postIdIndex IF NOT EXISTS FOR (p:Post) ON (p.id)",
    ];

    let queries = constraints.iter().chain(indexes.iter());

    let graph = get_neo4j_graph()?;
    let graph = graph.lock().await;
    for q in queries {
        graph.run(query(q)).await?;
    }

    Ok(())
}

// Create nodes with Merge (avoid key duplication). Examples:
// MERGE (u:User {id: "4snwyct86m383rsduhw5xgcxpw7c63j3pq8x4ycqikxgik8y64ro"}) SET u.name = "Aldert", u.status = "working", u.links = ...
// MERGE (p:Post {id: "0RDV7ABDZDW0"}) SET p.content = "Julian Assange is free", p.uri = "pubky:pxnu33x7jtpx9ar1ytsi4yxbp6a5o36gwhffs8zoxmbuptici1jy/pubky.app/posts/0RDV7ABDZDW0", p.createdAt = 1719308315917;

// Retrieve post node by post id and author id
pub fn get_post_by_id(author_id: &str, post_id: &str) -> Query {
    query("MATCH (u:User {id: $author_id})-[:AUTHORED]->(p:Post {id: $post_id}) RETURN p")
        .param("author_id", author_id)
        .param("post_id", post_id)
}

pub fn post_counts(author_id: &str, post_id: &str) -> Query {
    query(
        "MATCH (u:User {id: $author_id})-[:AUTHORED]->(p:Post {id: $post_id})
         OPTIONAL MATCH (p)<-[tag:TAGGED]-()
         OPTIONAL MATCH (p)<-[reply:REPLIED]-()
         OPTIONAL MATCH (p)<-[repost:REPOSTED]-()
         RETURN COUNT(p) > 0 AS post_exists,
                COUNT(DISTINCT tag) AS tags_count,
                COUNT(DISTINCT reply) AS replies_count,
                COUNT(DISTINCT repost) AS reposts_count",
    )
    .param("author_id", author_id)
    .param("post_id", post_id)
}

pub fn post_bookmark(author_id: &str, post_id: &str, viewer_id: &str) -> Query {
    query(
        "MATCH (u:User {id: $author_id})-[:AUTHORED]->(p:Post {id: $post_id})
         OPTIONAL MATCH (viewer:User {id: $viewer_id})-[b:BOOKMARKED]->(p)
         RETURN b",
    )
    .param("author_id", author_id)
    .param("post_id", post_id)
    .param("viewer_id", viewer_id)
}

pub fn post_relationships(author_id: &str, post_id: &str) -> Query {
    query(
        "MATCH (u:User {id: $author_id})-[:AUTHORED]->(p:Post {id: $post_id})
        OPTIONAL MATCH (p)-[:REPLIED]->(replied_post:Post)<-[:AUTHORED]-(replied_author:User)
        OPTIONAL MATCH (p)-[:REPOSTED]->(reposted_post:Post)<-[:AUTHORED]-(reposted_author:User)
        OPTIONAL MATCH (p)-[:MENTIONED]->(mentioned_user:User)
        RETURN 
          replied_post.id AS replied_post_id, 
          replied_author.id AS replied_author_id,
          reposted_post.id AS reposted_post_id, 
          reposted_author.id AS reposted_author_id,
          COLLECT(mentioned_user.id) AS mentioned_user_ids",
    )
    .param("author_id", author_id)
    .param("post_id", post_id)
}

// Retrive user node by id (pk)
pub fn get_user_by_id(user_id: &str) -> Query {
    query("MATCH (u:User {id: $id}) RETURN u").param("id", user_id)
}

pub fn user_tags(user_id: &str) -> neo4rs::Query {
    query(
        "MATCH (u:User {id: $id})<-[t:TAGGED_AS]-(author:User)
           RETURN t.label AS tag .....",
    )
    .param("id", user_id)
}

pub fn user_counts(user_id: &str) -> neo4rs::Query {
    query(
        "MATCH (u:User {id: $id})
           OPTIONAL MATCH (u)-[:FOLLOWS]->(following:User)
           OPTIONAL MATCH (follower:User)-[:FOLLOWS]->(u)
           OPTIONAL MATCH (u)-[:FOLLOWS]->(friend:User)-[:FOLLOWS]->(u)
           OPTIONAL MATCH (u)-[:AUTHORED]->(post:Post)
           OPTIONAL MATCH (u)-[tag:TAGGED]->(:Post)
           RETURN COUNT(u) > 0 AS user_exists,
                  COUNT(DISTINCT following) AS following_count,
                  COUNT(DISTINCT follower) AS followers_count,
                  COUNT(DISTINCT friend) AS friends_count,
                  COUNT(DISTINCT post) AS posts_count,
                  COUNT(DISTINCT tag) AS tags_count",
    )
    .param("id", user_id)
}

pub fn viewer_relationship(user_id: &str, viewer_id: &str) -> neo4rs::Query {
    query(
        "MATCH (u:User {id: $user_id})
         OPTIONAL MATCH (viewer:User {id: $viewer_id})
         RETURN EXISTS((viewer)-[:FOLLOWS]->(u)) AS following,
                EXISTS((u)-[:FOLLOWS]->(viewer)) AS followed_by,
                COUNT(u) > 0 AS user_exists,
                COUNT(viewer) > 0 AS viewer_exists",
    )
    .param("user_id", user_id)
    .param("viewer_id", viewer_id)
}

pub fn get_user_followers(user_id: &str) -> Query {
    query("MATCH (u:User {id: $user_id})<-[:FOLLOWS]-(follower:User) RETURN COLLECT(follower.id) AS follower_ids")
        .param("user_id", user_id)
}

pub fn get_user_following(user_id: &str) -> Query {
    query("MATCH (u:User {id: $user_id})-[:FOLLOWS]->(following:User) RETURN COLLECT(following.id) AS following_ids")
        .param("user_id", user_id)
}
```
./src/setup.rs
```
use crate::config::Config;
use crate::db::connectors::{
    neo4j::{Neo4jConnector, NEO4J_CONNECTOR},
    redis::{RedisConnector, REDIS_CONNECTOR},
};
use crate::queries::setup_graph;
use log::{error, info};

async fn setup_redis(config: &Config) {
    let redis_connector = RedisConnector::new_connection(&config.redis_uri())
        .await
        .expect("Failed to connect to Redis");

    match REDIS_CONNECTOR.set(redis_connector) {
        Err(e) => error!("RedisConnector was already set: {:?}", e),
        Ok(()) => info!("RedisConnector successfully set"),
    }
}

async fn setup_neo4j(config: &Config) {
    let neo4j_connector = Neo4jConnector::new_connection(
        &config.neo4j_uri(),
        &config.neo4j_username,
        &config.neo4j_password,
    )
    .await
    .expect("Failed to connect to Neo4j");

    match NEO4J_CONNECTOR.set(neo4j_connector) {
        Err(e) => error!("Neo4jConnector was already set: {:?}", e),
        Ok(()) => info!("Neo4jConnector successfully set"),
    }

    // Set Neo4J graph data constraints
    setup_graph().await.unwrap_or_default();
}

pub async fn setup(config: &Config) {
    env_logger::init();

    // Initialize Redis and Neo4j
    setup_redis(config).await;
    setup_neo4j(config).await;
}
```
./src/reindex.rs
```
use crate::models::user::{Follows, FollowsVariant};
use crate::{
    db::connectors::neo4j::get_neo4j_graph,
    models::post::{PostCounts, PostDetails, PostRelationships},
    models::user::{UserCounts, UserDetails},
};
use log::info;
use neo4rs::query;
use tokio::task::JoinSet;

pub async fn reindex() {
    let mut user_tasks = JoinSet::new();
    let mut post_tasks = JoinSet::new();

    let user_ids = get_all_user_ids().await.expect("Failed to get user IDs");
    for user_id in user_ids {
        user_tasks.spawn(async move {
            if let Err(e) = reindex_user(&user_id).await {
                log::error!("Failed to reindex user {}: {:?}", user_id, e);
            }
        });
    }

    let post_ids = get_all_post_ids().await.expect("Failed to get post IDs");
    for (author_id, post_id) in post_ids {
        post_tasks.spawn(async move {
            if let Err(e) = reindex_post(&author_id, &post_id).await {
                log::error!("Failed to reindex post {}: {:?}", post_id, e);
            }
        });
    }

    while let Some(res) = user_tasks.join_next().await {
        if let Err(e) = res {
            log::error!("User reindexing task failed: {:?}", e);
        }
    }

    while let Some(res) = post_tasks.join_next().await {
        if let Err(e) = res {
            log::error!("Post reindexing task failed: {:?}", e);
        }
    }

    info!("Reindexing completed successfully.");
}

async fn reindex_user(user_id: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    tokio::try_join!(
        UserDetails::get_from_graph(user_id),
        UserCounts::get_from_graph(user_id),
        Follows::get_from_graph(user_id, &FollowsVariant::Followers)
    )?;

    Ok(())
}

async fn reindex_post(
    author_id: &str,
    post_id: &str,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    tokio::try_join!(
        PostDetails::get_from_graph(author_id, post_id),
        PostCounts::get_from_graph(author_id, post_id),
        PostRelationships::get_from_graph(author_id, post_id)
    )?;

    Ok(())
}

async fn get_all_user_ids() -> Result<Vec<String>, Box<dyn std::error::Error + Send + Sync>> {
    let graph = get_neo4j_graph()?;
    let query = query("MATCH (u:User) RETURN u.id AS id");

    let graph = graph.lock().await;
    let mut result = graph.execute(query).await?;

    let mut user_ids = Vec::new();
    while let Some(row) = result.next().await? {
        if let Some(id) = row.get("id")? {
            user_ids.push(id);
        }
    }

    Ok(user_ids)
}

async fn get_all_post_ids(
) -> Result<Vec<(String, String)>, Box<dyn std::error::Error + Send + Sync>> {
    let graph = get_neo4j_graph()?;
    let query =
        query("MATCH (u:User)-[:AUTHORED]->(p:Post) RETURN u.id AS author_id, p.id AS post_id");

    let graph = graph.lock().await;
    let mut result = graph.execute(query).await?;

    let mut post_ids = Vec::new();
    while let Some(row) = result.next().await? {
        if let (Some(author_id), Some(post_id)) = (row.get("author_id")?, row.get("post_id")?) {
            post_ids.push((author_id, post_id));
        }
    }

    Ok(post_ids)
}
```
./src/lib.rs
```
mod config;
mod db;
mod error;
pub mod models;
mod reindex;
pub mod routes;
mod setup;

pub use config::Config;
pub use db::graph::queries;
pub use db::kv::traits::RedisOps;
pub use error::{Error, Result};
pub use reindex::reindex;
pub use setup::setup;
```
./src/config.rs
```
use dotenv::dotenv;
use std::env;

#[derive(Debug, Clone)]
pub struct Config {
    neo4j_host: String,
    neo4j_port: String,
    pub neo4j_username: String,
    pub neo4j_password: String,
    redis_host: String,
    redis_port: String,
    pub static_path: String,
    server_host: String,
    server_port: String,
    pub reindex: bool,
}

impl Config {
    pub fn from_env() -> Self {
        dotenv().ok();

        Self {
            neo4j_host: env::var("NEO4J_HOST").unwrap_or_else(|_| "localhost".to_string()),
            neo4j_port: env::var("NEO4J_PORT").unwrap_or_else(|_| "7687".to_string()),
            neo4j_username: env::var("NEO4J_DB_USERNAME").expect("NEO4J_DB_USERNAME not set"),
            neo4j_password: env::var("NEO4J_PASSWORD").expect("NEO4J_PASSWORD not set"),
            redis_host: env::var("REDIS_HOST").unwrap_or_else(|_| "localhost".to_string()),
            redis_port: env::var("REDIS_PORT").unwrap_or_else(|_| "6379".to_string()),
            static_path: env::var("STATIC_PATH").unwrap_or_else(|_| "./".to_string()),
            server_host: env::var("SERVER_HOST").unwrap_or_else(|_| "127.0.0.1".to_string()),
            server_port: env::var("SERVER_PORT").unwrap_or_else(|_| "8080".to_string()),
            reindex: env::var("REINDEX")
                .unwrap_or_else(|_| "false".to_string())
                .parse()
                .unwrap_or(false),
        }
    }

    pub fn neo4j_uri(&self) -> String {
        format!("bolt://{}:{}", self.neo4j_host, self.neo4j_port)
    }

    pub fn redis_uri(&self) -> String {
        format!("redis://{}:{}", self.redis_host, self.redis_port)
    }

    pub fn server_binding(&self) -> String {
        format!("{}:{}", self.server_host, self.server_port)
    }
}
```
./src/service.rs
```
use log::info;
use pubky_nexus::{reindex, routes, setup, Config};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() {
    let config = Config::from_env();
    setup(&config).await;

    // Reindex if REINDEX is set to true
    match config.reindex {
        true => {
            info!("REINDEX=true detected. Starting reindexing process.");
            reindex().await;
        }
        false => (),
    }

    // App router
    let app = routes::routes();

    // Start server
    let listener = TcpListener::bind(&config.server_binding()).await.unwrap();
    info!("Listening on {:?}\n", listener.local_addr().unwrap());
    axum::serve(listener, app.into_make_service())
        .await
        .unwrap();
}
```
./src/error.rs
```
use axum::http::StatusCode;
use axum::response::{IntoResponse, Response};
use log::{debug, error};
use thiserror::Error;

pub type Result<T> = core::result::Result<T, Error>;

#[derive(Error, Debug)]
pub enum Error {
    #[error("User not found: {user_id}")]
    UserNotFound { user_id: String },
    #[error("Post not found: {author_id} {post_id}")]
    PostNotFound { author_id: String, post_id: String },
    #[error("Internal server error: {source}")]
    InternalServerError { source: Box<dyn std::error::Error> },
    // Add other custom errors here
}

impl IntoResponse for Error {
    fn into_response(self) -> Response {
        // HTTP Status codes
        let status_code = match self {
            Error::UserNotFound { .. } => StatusCode::NOT_FOUND,
            Error::PostNotFound { .. } => StatusCode::NOT_FOUND,
            Error::InternalServerError { .. } => StatusCode::INTERNAL_SERVER_ERROR,
            // Map other errors to appropriate status codes
        };

        // Logging
        match &self {
            Error::UserNotFound { user_id } => debug!("User not found: {}", user_id),
            Error::PostNotFound { author_id, post_id } => {
                debug!("Post not found: {} {}", author_id, post_id)
            }
            Error::InternalServerError { source } => error!("Internal server error: {:?}", source),
        };

        let body = serde_json::json!({
            "error": self.to_string()
        });

        (status_code, axum::Json(body)).into_response()
    }
}
```
./src/models/mod.rs
```
pub mod info;
pub mod post;
pub mod user;
```
./src/models/post/tags.rs
```
use crate::models::user::UserDetails;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

/// Represents a tag with its tag label, count, and author sources.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct PostTag {
    label: String,
    count: u32,
    by: Vec<UserDetails>,
}

impl Default for PostTag {
    fn default() -> Self {
        Self::new()
    }
}

impl PostTag {
    pub fn new() -> Self {
        Self {
            label: String::new(),
            count: 0,
            by: vec![UserDetails::new()],
        }
    }
}

/// Represents a collection of PostTag.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct PostTags {
    tags: Vec<PostTag>,
}

impl Default for PostTags {
    fn default() -> Self {
        Self::new()
    }
}

impl PostTags {
    pub fn new() -> Self {
        Self { tags: Vec::new() }
    }

    /// TODO: Retrieves tags by user ID, currently returns an empty instance.
    pub async fn get_by_id(_user_id: &str) -> Result<Option<Self>, Box<dyn std::error::Error>> {
        Ok(Some(Self::new()))
    }
}
```
./src/models/post/mod.rs
```
mod bookmark;
mod counts;
mod details;
mod relationships;
mod tags;
mod view;

pub use bookmark::Bookmark;
pub use counts::PostCounts;
pub use details::PostDetails;
pub use relationships::PostRelationships;
pub use tags::PostTag;
pub use tags::PostTags;
pub use view::PostView;
```
./src/models/post/bookmark.rs
```
use crate::db::connectors::neo4j::get_neo4j_graph;
use crate::{queries, RedisOps};
use chrono::Utc;
use neo4rs::Relation;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

#[derive(Serialize, Deserialize, ToSchema)]
pub struct Bookmark {
    id: String,
    indexed_at: i64,
}

impl RedisOps for Bookmark {}

impl Default for Bookmark {
    fn default() -> Self {
        Self::new()
    }
}

impl Bookmark {
    pub fn new() -> Self {
        Self {
            id: String::new(),
            indexed_at: Utc::now().timestamp(),
        }
    }

    /// Retrieves counts by user ID, first trying to get from Redis, then from Neo4j if not found.
    pub async fn get_by_id(
        author_id: &str,
        post_id: &str,
        viewer_id: Option<&str>,
    ) -> Result<Option<Bookmark>, Box<dyn std::error::Error + Send + Sync>> {
        // Return None early if no viewer_id supplied
        let viewer_id = match viewer_id {
            Some(viewer_id) => viewer_id,
            None => return Ok(None),
        };
        match Self::try_from_index(&[author_id, post_id, viewer_id]).await? {
            Some(counts) => Ok(Some(counts)),
            None => Self::get_from_graph(author_id, post_id, viewer_id).await,
        }
    }

    /// Retrieves the counts from Neo4j.
    pub async fn get_from_graph(
        author_id: &str,
        post_id: &str,
        viewer_id: &str,
    ) -> Result<Option<Bookmark>, Box<dyn std::error::Error + Send + Sync>> {
        let graph = get_neo4j_graph()?;
        let query = queries::post_bookmark(author_id, post_id, viewer_id);

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        if let Some(row) = result.next().await? {
            let relation: Relation = row.get("b").unwrap();
            let counts = Self {
                id: relation.get("id").unwrap_or_default(),
                indexed_at: relation.get("indexed_at").unwrap_or_default(),
            };
            counts.set_index(&[author_id, post_id, viewer_id]).await?;
            Ok(Some(counts))
        } else {
            Ok(None)
        }
    }
}
```
./src/models/post/details.rs
```
use crate::db::connectors::neo4j::get_neo4j_graph;
use crate::{queries, RedisOps};
use chrono::Utc;
use neo4rs::Node;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

/// Represents post data with content, bio, image, links, and status.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct PostDetails {
    content: String,
    id: String, // TODO: create Crockfordbase32 validator
    indexed_at: i64,
    author: String,
    uri: String,
}

impl RedisOps for PostDetails {}

impl Default for PostDetails {
    fn default() -> Self {
        Self::new()
    }
}

impl PostDetails {
    pub fn new() -> Self {
        Self {
            content: String::new(),
            id: String::new(),
            indexed_at: Utc::now().timestamp(),
            author: String::new(),
            uri: String::new(),
        }
    }

    /// Retrieves post details by author ID and post ID, first trying to get from Redis, then from Neo4j if not found.
    pub async fn get_by_id(
        author_id: &str,
        post_id: &str,
    ) -> Result<Option<PostDetails>, Box<dyn std::error::Error + Send + Sync>> {
        match Self::try_from_index(&[author_id, post_id]).await? {
            Some(details) => Ok(Some(details)),
            None => Self::get_from_graph(author_id, post_id).await,
        }
    }

    async fn from_node(node: &Node, author_id: &str) -> Self {
        let id = node.get("id").unwrap_or_default();
        Self {
            uri: format!("pubky:{author_id}/pubky.app/posts/{id}"),
            content: node.get("content").unwrap_or_default(),
            id,
            indexed_at: node.get("indexed_at").unwrap_or_default(),
            author: String::from(author_id),
        }
    }

    /// Retrieves the post fields from Neo4j.
    pub async fn get_from_graph(
        author_id: &str,
        post_id: &str,
    ) -> Result<Option<PostDetails>, Box<dyn std::error::Error + Send + Sync>> {
        let graph = get_neo4j_graph()?;
        let query = queries::get_post_by_id(author_id, post_id);

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        match result.next().await? {
            Some(row) => {
                let node: Node = row.get("p")?;
                let post = Self::from_node(&node, author_id).await;
                post.set_index(&[author_id, post_id]).await?;
                Ok(Some(post))
            }
            None => Ok(None),
        }
    }
}
```
./src/models/post/relationships.rs
```
use crate::db::connectors::neo4j::get_neo4j_graph;
use crate::{queries, RedisOps};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

#[derive(Serialize, Deserialize, ToSchema)]
pub struct PostRelationships {
    // URI of the replied post
    replied: Option<String>,
    // URI of the reposted post
    reposted: Option<String>,
    // List of user IDs
    mentioned: Option<Vec<String>>,
}

impl RedisOps for PostRelationships {}

impl Default for PostRelationships {
    fn default() -> Self {
        Self::new()
    }
}

impl PostRelationships {
    pub fn new() -> Self {
        Self {
            replied: None,
            reposted: None,
            mentioned: None,
        }
    }

    /// Retrieves post relationships by user ID, first trying to get from Redis, then from Neo4j if not found.
    pub async fn get_by_id(
        author_id: &str,
        post_id: &str,
    ) -> Result<Option<PostRelationships>, Box<dyn std::error::Error + Send + Sync>> {
        match Self::try_from_index(&[author_id, post_id]).await? {
            Some(counts) => Ok(Some(counts)),
            None => Self::get_from_graph(author_id, post_id).await,
        }
    }

    /// Retrieves the counts from Neo4j.
    pub async fn get_from_graph(
        author_id: &str,
        post_id: &str,
    ) -> Result<Option<PostRelationships>, Box<dyn std::error::Error + Send + Sync>> {
        let graph = get_neo4j_graph()?;
        let query = queries::post_relationships(author_id, post_id);

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        if let Some(row) = result.next().await? {
            let replied_post_id: Option<String> = row.get("replied_post_id")?;
            let replied_author_id: Option<String> = row.get("replied_author_id")?;
            let reposted_post_id: Option<String> = row.get("reposted_post_id")?;
            let reposted_author_id: Option<String> = row.get("reposted_author_id")?;
            let mentioned: Option<Vec<String>> = row.get("mentioned_user_ids")?;

            let replied = match (replied_author_id, replied_post_id) {
                (Some(author_id), Some(post_id)) => {
                    Some(format!("pubky:{author_id}/pubky.app/posts/{post_id}"))
                }
                _ => None,
            };
            let reposted = match (reposted_author_id, reposted_post_id) {
                (Some(author_id), Some(post_id)) => {
                    Some(format!("pubky:{author_id}/pubky.app/posts/{post_id}"))
                }
                _ => None,
            };
            let relationships = Self {
                replied,
                reposted,
                mentioned,
            };
            relationships.set_index(&[author_id, post_id]).await?;
            Ok(Some(relationships))
        } else {
            Ok(None)
        }
    }
}
```
./src/models/post/counts.rs
```
use crate::db::connectors::neo4j::get_neo4j_graph;
use crate::{queries, RedisOps};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

/// Represents total counts of relationships of a user.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct PostCounts {
    pub tags: u32,
    pub replies: u32,
    pub reposts: u32,
}

impl RedisOps for PostCounts {}

impl Default for PostCounts {
    fn default() -> Self {
        Self::new()
    }
}

impl PostCounts {
    pub fn new() -> Self {
        Self {
            tags: 0,
            replies: 0,
            reposts: 0,
        }
    }

    /// Retrieves counts by user ID, first trying to get from Redis, then from Neo4j if not found.
    pub async fn get_by_id(
        author_id: &str,
        post_id: &str,
    ) -> Result<Option<PostCounts>, Box<dyn std::error::Error + Send + Sync>> {
        match Self::try_from_index(&[author_id, post_id]).await? {
            Some(counts) => Ok(Some(counts)),
            None => Self::get_from_graph(author_id, post_id).await,
        }
    }

    /// Retrieves the counts from Neo4j.
    pub async fn get_from_graph(
        author_id: &str,
        post_id: &str,
    ) -> Result<Option<PostCounts>, Box<dyn std::error::Error + Send + Sync>> {
        let graph = get_neo4j_graph()?;
        let query = queries::post_counts(author_id, post_id);

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        if let Some(row) = result.next().await? {
            if !row.get("post_exists").unwrap_or(false) {
                return Ok(None);
            }
            let counts = Self {
                tags: row.get("tags_count").unwrap_or_default(),
                replies: row.get("replies_count").unwrap_or_default(),
                reposts: row.get("reposts_count").unwrap_or_default(),
            };
            counts.set_index(&[author_id, post_id]).await?;
            Ok(Some(counts))
        } else {
            Ok(None)
        }
    }
}
```
./src/models/post/view.rs
```
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use super::{Bookmark, PostCounts, PostDetails, PostRelationships, PostTags};

/// Represents a Pubky user with relational data including tags, counts, and relationship with a viewer.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct PostView {
    details: PostDetails,
    counts: PostCounts,
    tags: PostTags,
    relationships: PostRelationships,
    bookmark: Option<Bookmark>,
}

impl Default for PostView {
    fn default() -> Self {
        Self::new()
    }
}

impl PostView {
    pub fn new() -> Self {
        Self {
            details: PostDetails::new(),
            counts: PostCounts::new(),
            tags: PostTags::new(),
            relationships: PostRelationships::new(),
            bookmark: Some(Bookmark::new()),
        }
    }

    /// Retrieves a user ID, checking the cache first and then the graph database.
    pub async fn get_by_id(
        author_id: &str,
        post_id: &str,
        viewer_id: Option<&str>,
    ) -> Result<Option<Self>, Box<dyn std::error::Error + Send + Sync>> {
        // Perform all operations concurrently
        let (details, counts, bookmark, relationships) = tokio::try_join!(
            PostDetails::get_by_id(author_id, post_id),
            PostCounts::get_by_id(author_id, post_id),
            Bookmark::get_by_id(author_id, post_id, viewer_id),
            PostRelationships::get_by_id(author_id, post_id),
        )?;

        let details = match details {
            None => return Ok(None),
            Some(details) => details,
        };

        let counts = counts.unwrap_or_default();
        let relationships = relationships.unwrap_or_default();

        Ok(Some(Self {
            details,
            counts,
            bookmark,
            relationships,
            tags: PostTags::new(), //TODO
        }))
    }
}
```
./src/models/user/follows.rs
```
use crate::db::connectors::neo4j::get_neo4j_graph;
use crate::db::kv::index;
use crate::{queries, RedisOps};
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::error::Error;
use utoipa::ToSchema;

#[derive(Serialize, Deserialize, ToSchema)]
pub struct Follows(Vec<String>);

#[derive(Debug, PartialEq)]
pub enum FollowsVariant {
    Followers,
    Following,
}

impl AsRef<[String]> for Follows {
    fn as_ref(&self) -> &[String] {
        &self.0
    }
}

#[async_trait]
impl RedisOps for Follows {
    async fn set_multiple_indexes<T>(
        &self,
        key_parts_list: &[&[&str]],
    ) -> Result<(), Box<dyn Error + Send + Sync>>
    where
        Self: AsRef<[T]>,
        T: Serialize + Send + Sync,
    {
        let data: Vec<_> = key_parts_list
            .iter()
            .map(|key_parts| (key_parts.join(":"), true))
            .collect();

        index::set_multiple::<bool>(&Self::prefix().await, &data).await?;
        Ok(())
    }
}

impl Default for Follows {
    fn default() -> Self {
        Self::new()
    }
}

impl Follows {
    pub fn new() -> Self {
        Self(Vec::new())
    }

    pub async fn get_by_id(
        user_id: &str,
        variant: FollowsVariant,
    ) -> Result<Option<Self>, Box<dyn Error + Send + Sync>> {
        match Self::try_from_follows_indexes(user_id, &variant, None, None).await? {
            Some(follows) => Ok(Some(Self(follows))),
            None => Self::get_from_graph(user_id, &variant).await,
        }
    }

    async fn try_from_follows_indexes(
        user_id: &str,
        variant: &FollowsVariant,
        skip: Option<usize>,
        limit: Option<usize>,
    ) -> Result<Option<Vec<String>>, Box<dyn Error + Send + Sync>> {
        let (pattern, position) = match variant {
            FollowsVariant::Followers => (format!("*:{user_id}"), 1),
            FollowsVariant::Following => (format!("{user_id}:*"), 2),
        };
        let (keys, _) = index::get_bool_range(
            &Self::prefix().await,
            Some(pattern.as_str()),
            skip,
            limit,
            index::RangeReturnType::Keys,
        )
        .await?;

        if let Some(keys) = keys {
            if !keys.is_empty() {
                let ids = keys
                    .into_iter()
                    .map(|k| {
                        k.split(':')
                            .nth(position) // Extracts the relevant user ID part from the key
                            .unwrap()
                            .to_string()
                    })
                    .collect();
                Ok(Some(ids))
            } else {
                Ok(None)
            }
        } else {
            Ok(None)
        }
    }

    pub async fn get_from_graph(
        user_id: &str,
        variant: &FollowsVariant,
    ) -> Result<Option<Self>, Box<dyn Error + Send + Sync>> {
        let graph = get_neo4j_graph()?;
        let query = match variant {
            FollowsVariant::Followers => queries::get_user_followers(user_id),
            FollowsVariant::Following => queries::get_user_following(user_id),
        };

        let mut follows = Vec::new();

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        if let Some(row) = result.next().await? {
            let user_id_column = match variant {
                FollowsVariant::Followers => "follower_ids",
                FollowsVariant::Following => "following_ids",
            };

            if let Some(ids) = row.get::<Option<Vec<String>>>(user_id_column)? {
                follows.extend(ids);
            }
        }

        if !follows.is_empty() {
            let follows = Self(follows);
            let key_parts_list: Vec<Vec<&str>> = follows
                .0
                .iter()
                .map(|id| match variant {
                    FollowsVariant::Followers => vec![id.as_str(), user_id], // Follows:{follower_id}:{user_id}
                    FollowsVariant::Following => vec![user_id, id.as_str()], // Follows:{user_id}:{following_id}
                })
                .collect();

            let key_parts_slices: Vec<&[&str]> =
                key_parts_list.iter().map(|v| v.as_slice()).collect();

            follows.set_multiple_indexes(&key_parts_slices).await?;
            Ok(Some(follows))
        } else {
            Ok(None)
        }
    }
}
```
./src/models/user/relationship.rs
```
use std::error::Error;

use crate::db::connectors::neo4j::get_neo4j_graph;
use crate::db::kv::index::{get_bool, set};
use crate::{queries, RedisOps};
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use tokio::try_join;
use utoipa::ToSchema;

/// Represents the relationship of the user that views and user being viewed.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct Relationship {
    pub following: bool,
    pub followed_by: bool,
}

/// This implementation reuses the "Follows:" model prefix for Redis keys, leveraging existing
/// data storage structures to minimize memory usage. Instead of storing separate `Relationship:`
/// objects, it stores boolean flags indicating the status of the relationship (i.e., whether
/// the user is followed by or following another user). This approach optimizes data storage
/// and retrieval in Redis, ensuring efficient memory utilization and streamlined operations.
///
/// The implementation provides methods for setting and retrieving relationship data using
/// these boolean flags, including handling potential errors and ensuring consistent key
/// structures for easy access and modification.
#[async_trait]
impl RedisOps for Relationship {
    async fn prefix() -> String {
        String::from("Follows")
    }

    async fn set_index(&self, key_parts: &[&str]) -> Result<(), Box<dyn Error + Send + Sync>> {
        let (user_id, viewer_id) = match key_parts {
            [user_id, viewer_id] => (user_id, viewer_id),
            _ => return Err("Expected exactly two elements in key_parts".into()),
        };

        let prefix = Self::prefix().await;

        if self.followed_by {
            let key = format!("{user_id}:{viewer_id}");
            set(&prefix, &key, &true, None, None).await?;
        }
        if self.following {
            let key = format!("{viewer_id}:{user_id}");
            set(&prefix, &key, &true, None, None).await?;
        }

        Ok(())
    }

    async fn try_from_index(
        key_parts: &[&str],
    ) -> Result<Option<Self>, Box<dyn Error + Send + Sync>> {
        let (user_id, viewer_id) = match key_parts {
            [user_id, viewer_id] => (user_id, viewer_id),
            _ => return Err("Expected exactly two elements in key_parts".into()),
        };

        let prefix = Self::prefix().await;

        let following_key = format!("{viewer_id}:{user_id}");
        let followed_by_key = format!("{user_id}:{viewer_id}");

        let (following_result, followed_by_result) = try_join!(
            get_bool(&prefix, &following_key),
            get_bool(&prefix, &followed_by_key)
        )?;

        if following_result.is_none() && followed_by_result.is_none() {
            return Ok(None);
        }

        Ok(Some(Self {
            following: following_result.unwrap_or(false),
            followed_by: followed_by_result.unwrap_or(false),
        }))
    }
}

impl Default for Relationship {
    fn default() -> Self {
        Self::new()
    }
}

impl Relationship {
    pub fn new() -> Self {
        Self {
            following: false,
            followed_by: false,
        }
    }

    // Retrieves user-viewer relationship
    pub async fn get_by_id(
        user_id: &str,
        viewer_id: Option<&str>,
    ) -> Result<Option<Self>, Box<dyn std::error::Error + Send + Sync>> {
        match viewer_id {
            None => Ok(None),
            Some(v_id) => match Self::try_from_index(&[user_id, v_id]).await? {
                Some(indexed_relationship) => Ok(Some(indexed_relationship)),
                None => Self::get_from_graph(user_id, v_id).await,
            },
        }
    }

    /// Retrieves the relationship from Neo4j and indexes it in Redis.
    pub async fn get_from_graph(
        user_id: &str,
        viewer_id: &str,
    ) -> Result<Option<Relationship>, Box<dyn std::error::Error + Send + Sync>> {
        let graph = get_neo4j_graph()?;

        let query = queries::viewer_relationship(user_id, viewer_id);
        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        if let Some(row) = result.next().await? {
            let user_exists: bool = row.get("user_exists").unwrap_or(false);
            let viewer_exists: bool = row.get("viewer_exists").unwrap_or(false);

            if !user_exists || !viewer_exists {
                return Ok(None);
            }

            let relationship = Self {
                following: row.get("following").unwrap_or(false),
                followed_by: row.get("followed_by").unwrap_or(false),
            };
            relationship.set_index(&[user_id, viewer_id]).await?;
            Ok(Some(relationship))
        } else {
            Ok(None)
        }
    }
}
```
./src/models/user/tags.rs
```
use super::UserDetails;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

/// Represents a tag with its tag label, count, and author sources.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct ProfileTag {
    label: String,
    count: u32,
    by: Vec<UserDetails>,
}

impl Default for ProfileTag {
    fn default() -> Self {
        Self::new()
    }
}

impl ProfileTag {
    pub fn new() -> Self {
        Self {
            label: String::new(),
            count: 0,
            by: vec![UserDetails::new()],
        }
    }
}

/// Represents a collection of ProfileTag.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct UserTags {
    tags: Vec<ProfileTag>,
}

impl Default for UserTags {
    fn default() -> Self {
        Self::new()
    }
}

impl UserTags {
    pub fn new() -> Self {
        Self { tags: Vec::new() }
    }

    /// TODO: Retrieves tags by user ID, currently returns an empty instance.
    pub async fn get_by_id(_user_id: &str) -> Result<Option<Self>, Box<dyn std::error::Error>> {
        Ok(Some(Self::new()))
    }
}
```
./src/models/user/mod.rs
```
mod counts;
mod details;
mod follows;
mod relationship;
mod tags;
mod view;

pub use counts::UserCounts;
pub use details::UserDetails;
pub use details::UserLink;
pub use follows::{Follows, FollowsVariant};
pub use relationship::Relationship;
pub use tags::ProfileTag;
pub use tags::UserTags;
pub use view::UserView;
```
./src/models/user/details.rs
```
use crate::db::connectors::neo4j::get_neo4j_graph;
use crate::{queries, RedisOps};
use chrono::Utc;
use neo4rs::Node;
use pkarr::PublicKey;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

#[derive(Serialize, Deserialize, ToSchema)]
pub struct UserLink {
    title: String,
    url: String,
}

impl Default for UserLink {
    fn default() -> Self {
        Self::new()
    }
}

/// Represents a user's single link with a title and URL.
impl UserLink {
    pub fn new() -> Self {
        Self {
            title: String::new(),
            url: String::new(),
        }
    }
}

/// Represents user data with name, bio, image, links, and status.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct UserDetails {
    name: String,
    bio: String,
    id: String,
    links: Vec<UserLink>,
    status: String,
    indexed_at: i64,
}

impl Default for UserDetails {
    fn default() -> Self {
        Self::new()
    }
}

impl RedisOps for UserDetails {}

impl UserDetails {
    pub fn new() -> Self {
        Self {
            name: String::new(),
            bio: String::new(),
            id: String::new(),
            links: vec![UserLink::new()],
            status: String::new(),
            indexed_at: Utc::now().timestamp(),
        }
    }

    /// Retrieves details by user ID, first trying to get from Redis, then from Neo4j if not found.
    pub async fn get_by_id(
        user_id: &str,
    ) -> Result<Option<UserDetails>, Box<dyn std::error::Error + Send + Sync>> {
        match Self::try_from_index(&[user_id]).await? {
            Some(details) => Ok(Some(details)),
            None => Self::get_from_graph(user_id).await,
        }
    }

    async fn from_node(node: &Node) -> Option<Self> {
        // TODO validation of ID should happen when we WRITE a Post into the graph with the watcher.
        let id: String = node.get("id").unwrap_or_default();
        PublicKey::try_from(id.clone()).ok()?;

        Some(Self {
            id,
            name: node.get("name").unwrap_or_default(),
            bio: node.get("bio").unwrap_or_default(),
            status: node.get("status").unwrap_or_default(),
            links: node.get("links").unwrap_or_default(),
            indexed_at: node.get("indexed_at").unwrap_or_default(),
        })
    }

    /// Retrieves the details from Neo4j.
    pub async fn get_from_graph(
        user_id: &str,
    ) -> Result<Option<UserDetails>, Box<dyn std::error::Error + Send + Sync>> {
        let graph = get_neo4j_graph()?;
        let query = queries::get_user_by_id(user_id);

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        match result.next().await? {
            Some(row) => {
                let node: Node = row.get("u")?;
                match Self::from_node(&node).await {
                    Some(details) => {
                        details.set_index(&[user_id]).await?;
                        Ok(Some(details))
                    }
                    None => Ok(None),
                }
            }
            None => Ok(None),
        }
    }
}
```
./src/models/user/counts.rs
```
use crate::db::connectors::neo4j::get_neo4j_graph;
use crate::{queries, RedisOps};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

/// Represents total counts of relationships of a user.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct UserCounts {
    pub tags: u32,
    pub posts: u32,
    pub following: u32,
    pub followers: u32,
    pub friends: u32,
}

impl RedisOps for UserCounts {}

impl Default for UserCounts {
    fn default() -> Self {
        Self::new()
    }
}

impl UserCounts {
    pub fn new() -> Self {
        Self {
            tags: 0,
            posts: 0,
            followers: 0,
            following: 0,
            friends: 0,
        }
    }

    /// Retrieves counts by user ID, first trying to get from Redis, then from Neo4j if not found.
    pub async fn get_by_id(
        user_id: &str,
    ) -> Result<Option<UserCounts>, Box<dyn std::error::Error + Send + Sync>> {
        match Self::try_from_index(&[user_id]).await? {
            Some(counts) => Ok(Some(counts)),
            None => Self::get_from_graph(user_id).await,
        }
    }

    /// Retrieves the counts from Neo4j.
    pub async fn get_from_graph(
        user_id: &str,
    ) -> Result<Option<UserCounts>, Box<dyn std::error::Error + Send + Sync>> {
        let graph = get_neo4j_graph()?;
        let query = queries::user_counts(user_id);

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        if let Some(row) = result.next().await? {
            if !row.get("user_exists").unwrap_or(false) {
                return Ok(None);
            }
            let counts = Self {
                following: row.get("following_count").unwrap_or_default(),
                followers: row.get("followers_count").unwrap_or_default(),
                friends: row.get("friends_count").unwrap_or_default(),
                posts: row.get("posts_count").unwrap_or_default(),
                tags: row.get("tags_count").unwrap_or_default(),
            };
            counts.set_index(&[user_id]).await?;
            Ok(Some(counts))
        } else {
            Ok(None)
        }
    }
}
```
./src/models/user/view.rs
```
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use super::{Relationship, UserCounts, UserDetails, UserTags};

/// Represents a Pubky user with relational data including tags, counts, bookmark and relationship with other posts.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct UserView {
    details: UserDetails,
    counts: UserCounts,
    tags: UserTags,
    viewer: Relationship,
}

impl Default for UserView {
    fn default() -> Self {
        Self::new()
    }
}

impl UserView {
    pub fn new() -> Self {
        Self {
            details: UserDetails::new(),
            counts: UserCounts::new(),
            tags: UserTags::new(),
            viewer: Relationship::new(),
        }
    }

    /// Retrieves a user by ID, checking the cache first and then the graph database.
    pub async fn get_by_id(
        user_id: &str,
        viewer_id: Option<&str>,
    ) -> Result<Option<Self>, Box<dyn std::error::Error + Send + Sync>> {
        // Perform all operations concurrently
        let (details, counts, viewer) = tokio::try_join!(
            UserDetails::get_by_id(user_id),
            UserCounts::get_by_id(user_id),
            Relationship::get_by_id(user_id, viewer_id)
        )?;

        let details = match details {
            None => return Ok(None),
            Some(details) => details,
        };

        let counts = counts.unwrap_or_default();
        let viewer = viewer.unwrap_or_default();

        Ok(Some(Self {
            details,
            counts,
            viewer,
            tags: UserTags::new(), //TODO
        }))
    }
}
```
./src/models/info.rs
```
use serde::Serialize;
use utoipa::ToSchema;

#[derive(Serialize, ToSchema)]
pub struct ServerInfo {
    pub description: String,
    pub homepage: String,
    pub license: String,
    pub name: String,
    pub repository: String,
    pub version: String,
}

impl Default for ServerInfo {
    fn default() -> Self {
        Self::new()
    }
}

impl ServerInfo {
    pub fn new() -> Self {
        Self {
            description: env!("CARGO_PKG_DESCRIPTION").to_string(),
            homepage: env!("CARGO_PKG_HOMEPAGE").to_string(),
            license: env!("CARGO_PKG_LICENSE").to_string(),
            name: env!("CARGO_PKG_NAME").to_string(),
            repository: env!("CARGO_PKG_REPOSITORY").to_string(),
            version: env!("CARGO_PKG_VERSION").to_string(),
        }
    }
}
```
./Cargo.toml
```
[package]
name = "pubky-nexus"
version = "0.1.0"
edition = "2021"
description = "Nexus between homeservers and Pubky-App. Pubky-nexus constructs a social graph out of all of the events on pubky-core homeservers and exposes a social-media-like API capable of powerful Web-of-Trust inference."
homepage = "https://github.com/pubky"
repository = "https://github.com/pubky/pubky-nexus"
license = "MIT"
default-run = "service"

[dependencies]
tokio = { version = "1.38.1", features = ["full"] }
axum = "0.7.5"
redis = { version = "0.25.4", features = ["tokio-comp", "json"] }
neo4rs = "0.7.2"
serde = { version = "1.0.204", features = ["derive"] }
serde_json = "1.0.120"
once_cell = "1.19.0"
utoipa = "4.2.3"
utoipa-swagger-ui = { version = "7.1.0", features = ["axum"] }
tower-http = { version = "0.5.2", features = ["fs"] }
dotenv = "0.15"
log = "0.4.22"
env_logger = "0.11.3"
const_format = "0.2.32"
thiserror = "1.0.63"
chrono = "0.4.38"
pkarr = { version = "2.1.0", features = ["async"], default-features = false }
async-trait = "0.1.81"

[dev-dependencies]
anyhow = "1.0.86"
httpc-test = "0.1.9"
criterion = { version = "0.5.1", features = ["async_tokio"] }

[lib]
name = "pubky_nexus"
path = "src/lib.rs"

[[bin]]

name = "service"
path = "src/service.rs"

[[bin]]
name = "watcher"
path = "src/watcher.rs"

[[bench]]
name = "user"
harness = false

[[bench]]
name = "post"
harness = false

[[bench]]
name = "reindex"
harness = false

[[bench]]
name = "follows"
harness = false

# Max performance profile
[profile.release]
opt-level = 3
codegen-units = 1
lto = true
incremental = false
```
