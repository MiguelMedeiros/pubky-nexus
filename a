./src/routes/static.rs
```
use crate::Config;
use axum::{routing::get_service, Router};
use tower_http::services::ServeDir;

pub fn routes() -> Router {
    let config = Config::from_env();
    Router::new().nest_service("/static", get_service(ServeDir::new(config.static_path)))
}
```
./src/routes/mod.rs
```
use axum::Router;

pub mod macros;
pub mod r#static;
pub mod v0;

pub fn routes() -> Router {
    let routes_v0 = v0::routes();
    let route_static = r#static::routes();

    routes_v0.merge(route_static)
}
```
./src/routes/macros.rs
```
#[macro_export]
macro_rules! register_routes {
    ($router:expr, $($path:expr => $handler:expr),* $(,)?) => {
        $router
            $(.route($path, axum::routing::get($handler)))*
    };
}
```
./src/routes/v0/stream/mod.rs
```
use crate::register_routes;
use crate::routes::v0::endpoints;
use axum::Router;
use utoipa::OpenApi;

mod posts;
mod users;

pub fn routes() -> Router {
    register_routes!(Router::new(),
        endpoints::STREAM_USERS_ROUTE => users::stream_users_handler,
        endpoints::STREAM_USERS_MOSTFOLLOWED_ROUTE => users::stream_most_followed_users_handler,
        endpoints::STREAM_POSTS_ROUTE => posts::stream_global_posts_handler,
        endpoints::STREAM_POSTS_USER_ROUTE => posts::stream_user_posts_handler,
        endpoints::STREAM_POSTS_REACH_ROUTE => posts::stream_posts_by_reach_handler,
        endpoints::STREAM_POSTS_BOOKMARKED_ROUTE => posts::stream_bookmarked_posts_handler
    )
}

#[derive(OpenApi)]
#[openapi()]
pub struct StreamApiDoc;

impl StreamApiDoc {
    pub fn merge_docs() -> utoipa::openapi::OpenApi {
        users::StreamUsersApiDocs::openapi();
        posts::StreamPostsApiDocs::openapi()
    }
}
```
./src/routes/v0/stream/users.rs
```
use crate::models::user::{UserStream, UserStreamType};
use crate::routes::v0::endpoints::{STREAM_USERS_MOSTFOLLOWED_ROUTE, STREAM_USERS_ROUTE};
use crate::{Error, Result};
use axum::extract::Query;
use axum::Json;
use log::info;
use serde::Deserialize;
use utoipa::OpenApi;

#[derive(Deserialize)]
pub struct UserStreamQuery {
    user_id: Option<String>,
    viewer_id: Option<String>,
    skip: Option<usize>,
    limit: Option<usize>,
    stream_type: Option<UserStreamType>,
}

#[utoipa::path(
    get,
    path = STREAM_USERS_ROUTE,
    tag = "Stream Users",
    params(
        ("user_id" = String, Path, description = "User Pubky ID"),
        ("viewer_id" = Option<String>, Query, description = "Viewer Pubky ID"),
        ("skip" = Option<usize>, Query, description = "Skip N followers"),
        ("limit" = Option<usize>, Query, description = "Retrieve N followers"),
        ("stream_type" = Option<UserStreamType>, Query, description = "Stream Type")
    ),
    responses(
        (status = 200, description = "Users stream", body = UserStream),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]

pub async fn stream_users_handler(
    Query(query): Query<UserStreamQuery>,
) -> Result<Json<UserStream>> {
    let user_id = match query.user_id {
        Some(user_id) => user_id,
        None => {
            return Err(Error::UserNotFound {
                user_id: "user_id query param not provided".to_string(),
            })
        }
    };

    info!("GET {STREAM_USERS_ROUTE} user_id:{}", user_id);

    let skip = query.skip.unwrap_or(0);
    let limit = query.limit.unwrap_or(20);
    let stream_type = query.stream_type.unwrap_or(UserStreamType::Followers);

    match UserStream::get_by_id(
        &user_id,
        query.viewer_id.as_deref(),
        Some(skip),
        Some(limit),
        stream_type,
    )
    .await
    {
        Ok(Some(stream)) => Ok(Json(stream)),
        Ok(None) => Err(Error::UserNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[utoipa::path(
    get,
    path = STREAM_USERS_MOSTFOLLOWED_ROUTE,
    tag = "Stream Most Followed Users",
    params(
        ("viewer_id" = Option<String>, Query, description = "Viewer Pubky ID"),
        ("skip" = Option<usize>, Query, description = "Skip N users"),
        ("limit" = Option<usize>, Query, description = "Retrieve N users"),
    ),
    responses(
        (status = 200, description = "Most followed users stream", body = UserStream),
        (status = 404, description = "No users found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn stream_most_followed_users_handler(
    Query(query): Query<UserStreamQuery>,
) -> Result<Json<UserStream>> {
    info!("GET {STREAM_USERS_MOSTFOLLOWED_ROUTE}");

    let skip = query.skip.unwrap_or(0);
    let limit = query.limit.unwrap_or(15);

    match UserStream::get_by_id(
        "", // No specific user ID is needed for most followed users
        query.viewer_id.as_deref(),
        Some(skip),
        Some(limit),
        UserStreamType::MostFollowed,
    )
    .await
    {
        Ok(Some(stream)) => Ok(Json(stream)),
        Ok(None) => Err(Error::UserNotFound {
            user_id: "Most Followed".to_string(),
        }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(
    paths(stream_users_handler, stream_most_followed_users_handler),
    components(schemas(UserStream, UserStreamType))
)]
pub struct StreamUsersApiDocs;
```
./src/routes/v0/stream/posts.rs
```
use crate::models::post::{PostStream, PostStreamReach, PostStreamSorting};
use crate::routes::v0::endpoints::{
    STREAM_POSTS_BOOKMARKED_ROUTE, STREAM_POSTS_REACH_ROUTE, STREAM_POSTS_ROUTE,
    STREAM_POSTS_USER_ROUTE,
};
use crate::{Error, Result};
use axum::extract::Query;
use axum::Json;
use log::info;
use serde::Deserialize;
use utoipa::OpenApi;

#[derive(Deserialize)]
pub struct PostStreamQuery {
    viewer_id: Option<String>,
    skip: Option<usize>,
    limit: Option<usize>,
    sorting: Option<PostStreamSorting>,
}

#[utoipa::path(
    get,
    path = STREAM_POSTS_ROUTE,
    tag = "Stream Posts",
    params(
        ("viewer_id" = Option<String>, Query, description = "Viewer Pubky ID"),
        ("skip" = Option<usize>, Query, description = "Skip N posts"),
        ("limit" = Option<usize>, Query, description = "Retrieve N posts"),
        ("sorting" = Option<PostStreamSorting>, Query, description = "Sorting method")
    ),
    responses(
        (status = 200, description = "Posts stream", body = PostStream),
        (status = 404, description = "Posts not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn stream_global_posts_handler(
    Query(query): Query<PostStreamQuery>,
) -> Result<Json<PostStream>> {
    info!("GET {STREAM_POSTS_ROUTE}");

    let skip = query.skip.unwrap_or(0);
    let limit = query.limit.unwrap_or(10);
    let sorting = query.sorting.unwrap_or(PostStreamSorting::Timeline);

    match PostStream::get_global_posts(sorting, query.viewer_id, Some(skip), Some(limit)).await {
        Ok(Some(stream)) => Ok(Json(stream)),
        Ok(None) => Err(Error::InternalServerError {
            source: "No posts found".into(),
        }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

use axum::extract::Path;

#[derive(Deserialize)]
pub struct UserPostStreamQuery {
    viewer_id: Option<String>,
    skip: Option<usize>,
    limit: Option<usize>,
}

#[utoipa::path(
    get,
    path = STREAM_POSTS_USER_ROUTE,
    tag = "Stream Posts by User",
    params(
        ("user_id" = String, Path, description = "User ID whose posts to retrieve"),
        ("viewer_id" = Option<String>, Query, description = "Viewer Pubky ID"),
        ("skip" = Option<usize>, Query, description = "Skip N posts"),
        ("limit" = Option<usize>, Query, description = "Retrieve N posts")
    ),
    responses(
        (status = 200, description = "User's posts stream", body = PostStream),
        (status = 404, description = "Posts not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn stream_user_posts_handler(
    Path(user_id): Path<String>,
    Query(query): Query<UserPostStreamQuery>,
) -> Result<Json<PostStream>> {
    info!("GET {STREAM_POSTS_USER_ROUTE}");

    let skip = query.skip.unwrap_or(0);
    let limit = query.limit.unwrap_or(10);

    match PostStream::get_user_posts(&user_id, query.viewer_id, Some(skip), Some(limit)).await {
        Ok(Some(stream)) => Ok(Json(stream)),
        Ok(None) => Err(Error::InternalServerError {
            source: "No posts found".into(),
        }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(Deserialize)]
pub struct PostStreamReachQuery {
    viewer_id: String,
    skip: Option<usize>,
    limit: Option<usize>,
    reach: Option<PostStreamReach>,
}

#[utoipa::path(
    get,
    path = STREAM_POSTS_REACH_ROUTE,
    tag = "Stream Posts by Reach",
    params(
        ("viewer_id" = String, Query, description = "Viewer Pubky ID"),
        ("reach" = PostStreamReach, Query, description = "Reach type (Following, Followers, Friends)"),
        ("skip" = Option<usize>, Query, description = "Skip N posts"),
        ("limit" = Option<usize>, Query, description = "Retrieve N posts")
    ),
    responses(
        (status = 200, description = "Posts stream by reach", body = PostStream),
        (status = 404, description = "Posts not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn stream_posts_by_reach_handler(
    Query(query): Query<PostStreamReachQuery>,
) -> Result<Json<PostStream>> {
    info!("GET {STREAM_POSTS_REACH_ROUTE}");

    let skip = query.skip.unwrap_or(0);
    let limit = query.limit.unwrap_or(10);
    let reach = query.reach.unwrap_or(PostStreamReach::Following);

    match PostStream::get_posts_by_reach(reach, Some(query.viewer_id), Some(skip), Some(limit))
        .await
    {
        Ok(Some(stream)) => Ok(Json(stream)),
        Ok(None) => Err(Error::InternalServerError {
            source: "No posts found".into(),
        }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(Deserialize)]
pub struct BookmarkedPostStreamQuery {
    skip: Option<usize>,
    limit: Option<usize>,
}

#[utoipa::path(
    get,
    path = STREAM_POSTS_BOOKMARKED_ROUTE,
    tag = "Stream Bookmarked Posts",
    params(
        ("user_id" = String, Path, description = "User ID whose bookmarked posts to retrieve"),
        ("viewer_id" = Option<String>, Query, description = "Viewer Pubky ID"),
        ("skip" = Option<usize>, Query, description = "Skip N posts"),
        ("limit" = Option<usize>, Query, description = "Retrieve N posts")
    ),
    responses(
        (status = 200, description = "Bookmarked posts stream", body = PostStream),
        (status = 404, description = "Posts not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn stream_bookmarked_posts_handler(
    Path(user_id): Path<String>,
    Query(query): Query<BookmarkedPostStreamQuery>,
) -> Result<Json<PostStream>> {
    info!("GET {STREAM_POSTS_BOOKMARKED_ROUTE}");

    let skip = query.skip.unwrap_or(0);
    let limit = query.limit.unwrap_or(10);

    match PostStream::get_bookmarked_posts(&user_id, Some(skip), Some(limit)).await {
        Ok(Some(stream)) => Ok(Json(stream)),
        Ok(None) => Err(Error::BookmarksNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(
    paths(
        stream_global_posts_handler,
        stream_user_posts_handler,
        stream_posts_by_reach_handler,
        stream_bookmarked_posts_handler
    ),
    components(schemas(PostStream, PostStreamSorting, PostStreamReach))
)]
pub struct StreamPostsApiDocs;
```
./src/routes/v0/mod.rs
```
use axum::Router;
use utoipa::OpenApi;
use utoipa_swagger_ui::SwaggerUi;

pub mod endpoints;
pub mod info;
pub mod post;
pub mod stream;
pub mod user;

pub fn routes() -> Router {
    let routes_info = info::routes();
    let routes_post = post::routes();
    let route_user = user::routes();
    let route_stream = stream::routes();
    let route_openapi =
        SwaggerUi::new("/swagger-ui").url("/api-docs/openapi.json", ApiDoc::merge_docs());

    routes_post
        .merge(routes_info)
        .merge(route_user)
        .merge(route_stream)
        .merge(route_openapi)
}

#[derive(OpenApi)]
#[openapi()]
pub struct ApiDoc;

impl ApiDoc {
    pub fn merge_docs() -> utoipa::openapi::OpenApi {
        let mut combined = post::PostApiDoc::merge_docs();
        combined.merge(info::InfoApiDoc::openapi());
        combined.merge(user::UserApiDoc::merge_docs());
        combined.merge(stream::StreamApiDoc::merge_docs());
        combined
    }
}
```
./src/routes/v0/endpoints.rs
```
use const_format::concatcp;

// Version routes
const VERSION_ROUTE: &str = "/v0";

// Info routes
pub const INFO_ROUTE: &str = concatcp!(VERSION_ROUTE, "/info");

// User routes
const USER_PREFIX: &str = concatcp!(VERSION_ROUTE, "/user");
pub const USER_ROUTE: &str = concatcp!(USER_PREFIX, "/:user_id");
pub const RELATIONSHIP_ROUTE: &str = concatcp!(USER_ROUTE, "/relationship/:viewer_id");
pub const USER_COUNTS_ROUTE: &str = concatcp!(USER_ROUTE, "/counts");
pub const USER_DETAILS_ROUTE: &str = concatcp!(USER_ROUTE, "/details");
pub const USER_TAGS_ROUTE: &str = concatcp!(USER_ROUTE, "/tags");
pub const USER_FOLLOWERS_ROUTE: &str = concatcp!(USER_ROUTE, "/followers");
pub const USER_FOLLOWING_ROUTE: &str = concatcp!(USER_ROUTE, "/following");
pub const USER_FRIENDS_ROUTE: &str = concatcp!(USER_ROUTE, "/friends");

// Post routes
const POST_PREFIX: &str = concatcp!(VERSION_ROUTE, "/post");
pub const POST_ROUTE: &str = concatcp!(POST_PREFIX, "/:author_id/:post_id");
pub const POST_RELATIONSHIPS_ROUTE: &str = concatcp!(POST_ROUTE, "/relationships");
pub const POST_BOOKMARK_ROUTE: &str = concatcp!(POST_ROUTE, "/bookmark");
pub const POST_COUNTS_ROUTE: &str = concatcp!(POST_ROUTE, "/counts");
pub const POST_DETAILS_ROUTE: &str = concatcp!(POST_ROUTE, "/details");
pub const POST_TAGS_ROUTE: &str = concatcp!(POST_ROUTE, "/tags");

// Stream routes
const STREAM_PREFIX: &str = concatcp!(VERSION_ROUTE, "/stream");
pub const STREAM_USERS_ROUTE: &str = concatcp!(STREAM_PREFIX, "/users");
pub const STREAM_USERS_MOSTFOLLOWED_ROUTE: &str = concatcp!(STREAM_PREFIX, "/users/most-followed");
pub const STREAM_POSTS_ROUTE: &str = concatcp!(STREAM_PREFIX, "/posts");
pub const STREAM_POSTS_USER_ROUTE: &str = concatcp!(STREAM_POSTS_ROUTE, "/user/:user_id");
pub const STREAM_POSTS_REACH_ROUTE: &str = concatcp!(STREAM_POSTS_ROUTE, "/reach");
pub const STREAM_POSTS_BOOKMARKED_ROUTE: &str =
    concatcp!(STREAM_POSTS_ROUTE, "/bookmarks/:user_id");
```
./src/routes/v0/post/mod.rs
```
use crate::register_routes;
use crate::routes::v0::endpoints;
use axum::Router;
use utoipa::OpenApi;

mod bookmark;
mod counts;
mod details;
mod view;

pub fn routes() -> Router {
    register_routes!(Router::new(),
        endpoints::POST_ROUTE => view::post_view_handler,
        endpoints::POST_DETAILS_ROUTE => details::post_details_handler,
        endpoints::POST_COUNTS_ROUTE => counts::post_counts_handler,
        endpoints::POST_BOOKMARK_ROUTE => bookmark::post_bookmark_handler,
    )
}

#[derive(OpenApi)]
#[openapi()]
pub struct PostApiDoc;

impl PostApiDoc {
    pub fn merge_docs() -> utoipa::openapi::OpenApi {
        let mut combined = view::PostViewApiDoc::openapi();
        combined.merge(counts::PostCountsApiDoc::openapi());
        combined.merge(bookmark::BookmarkApiDoc::openapi());
        combined.merge(details::PostDetailsApiDoc::openapi());
        combined
    }
}
```
./src/routes/v0/post/bookmark.rs
```
use crate::models::post::Bookmark;
use crate::routes::v0::endpoints::POST_BOOKMARK_ROUTE;
use crate::{Error, Result};
use axum::extract::{Path, Query};
use axum::Json;
use log::info;
use serde::Deserialize;
use utoipa::OpenApi;

#[derive(Deserialize)]
pub struct PostQuery {
    viewer_id: Option<String>,
}

#[utoipa::path(
    get,
    path = POST_BOOKMARK_ROUTE,
    tag = "Post Bookmark",
    params(
        ("author_id" = String, Path, description = "Author Pubky ID"),
        ("post_id" = String, Path, description = "Post Crockford32 ID"),
        ("viewer_id" = Option<String>, Query, description = "Viewer Pubky ID")
    ),
    responses(
        (status = 200, description = "Post Bookmark", body = Bookmark),
        (status = 404, description = "Post not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn post_bookmark_handler(
    Path((author_id, post_id)): Path<(String, String)>,
    Query(query): Query<PostQuery>,
) -> Result<Json<Bookmark>> {
    info!(
        "GET {POST_BOOKMARK_ROUTE} author_id:{}, post_id:{}, viewer_id:{}",
        author_id,
        post_id,
        query.viewer_id.clone().unwrap_or_default()
    );

    match Bookmark::get_by_id(&author_id, &post_id, query.viewer_id.as_deref()).await {
        Ok(Some(post)) => Ok(Json(post)),
        Ok(None) => Err(Error::PostNotFound { author_id, post_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(paths(post_bookmark_handler), components(schemas(Bookmark)))]
pub struct BookmarkApiDoc;
```
./src/routes/v0/post/details.rs
```
use crate::models::post::PostDetails;
use crate::routes::v0::endpoints::POST_DETAILS_ROUTE;
use crate::{Error, Result};
use axum::extract::Path;
use axum::Json;
use log::info;
use utoipa::OpenApi;

#[utoipa::path(
    get,
    path = POST_DETAILS_ROUTE,
    tag = "Post Details",
    params(
        ("author_id" = String, Path, description = "Author Pubky ID"),
        ("post_id" = String, Path, description = "Post Crockford32 ID")
    ),
    responses(
        (status = 200, description = "Post Details", body = PostDetails),
        (status = 404, description = "Post not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn post_details_handler(
    Path((author_id, post_id)): Path<(String, String)>,
) -> Result<Json<PostDetails>> {
    info!(
        "GET {POST_DETAILS_ROUTE} author_id:{}, post_id:{}",
        author_id, post_id
    );

    match PostDetails::get_by_id(&author_id, &post_id).await {
        Ok(Some(post)) => Ok(Json(post)),
        Ok(None) => Err(Error::PostNotFound { author_id, post_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(paths(post_details_handler), components(schemas(PostDetails)))]
pub struct PostDetailsApiDoc;
```
./src/routes/v0/post/counts.rs
```
use crate::models::post::PostCounts;
use crate::routes::v0::endpoints::POST_COUNTS_ROUTE;
use crate::{Error, Result};
use axum::extract::Path;
use axum::Json;
use log::info;
use utoipa::OpenApi;

#[utoipa::path(
    get,
    path = POST_COUNTS_ROUTE,
    tag = "Post Counts",
    params(
        ("author_id" = String, Path, description = "Author Pubky ID"),
        ("post_id" = String, Path, description = "Post Crockford32 ID")
    ),
    responses(
        (status = 200, description = "Post Counts", body = PostCounts),
        (status = 404, description = "Post not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn post_counts_handler(
    Path((author_id, post_id)): Path<(String, String)>,
) -> Result<Json<PostCounts>> {
    info!(
        "GET {POST_COUNTS_ROUTE} author_id:{}, post_id:{}",
        author_id, post_id
    );

    match PostCounts::get_by_id(&author_id, &post_id).await {
        Ok(Some(post)) => Ok(Json(post)),
        Ok(None) => Err(Error::PostNotFound { author_id, post_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(paths(post_counts_handler), components(schemas(PostCounts)))]
pub struct PostCountsApiDoc;
```
./src/routes/v0/post/view.rs
```
use crate::models::post::{PostRelationships, PostView};
use crate::models::tag::post::{PostTag, PostTags};
use crate::routes::v0::endpoints::POST_ROUTE;
use crate::{Error, Result};
use axum::extract::{Path, Query};
use axum::Json;
use log::info;
use serde::Deserialize;
use utoipa::OpenApi;

#[derive(Deserialize)]
pub struct PostQuery {
    viewer_id: Option<String>,
}

#[utoipa::path(
    get,
    path = POST_ROUTE,
    tag = "Post",
    params(
        ("author_id" = String, Path, description = "Author Pubky ID"),
        ("post_id" = String, Path, description = "Post Crockford32 ID"),
        ("viewer_id" = Option<String>, Query, description = "Viewer Pubky ID")
    ),
    responses(
        (status = 200, description = "Post", body = PostView),
        (status = 404, description = "Post not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn post_view_handler(
    Path((author_id, post_id)): Path<(String, String)>,
    Query(query): Query<PostQuery>,
) -> Result<Json<PostView>> {
    info!(
        "GET {POST_ROUTE} author_id:{}, post_id:{}, viewer_id:{}",
        author_id,
        post_id,
        query.viewer_id.clone().unwrap_or_default()
    );

    match PostView::get_by_id(&author_id, &post_id, query.viewer_id.as_deref()).await {
        Ok(Some(post)) => Ok(Json(post)),
        Ok(None) => Err(Error::PostNotFound { author_id, post_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(
    paths(post_view_handler),
    components(schemas(PostView, PostRelationships, PostTags, PostTag))
)]
pub struct PostViewApiDoc;
```
./src/routes/v0/user/follows.rs
```
use crate::models::user::{Followers, Following, Friends, UserFollows};
use crate::routes::v0::endpoints::{
    USER_FOLLOWERS_ROUTE, USER_FOLLOWING_ROUTE, USER_FRIENDS_ROUTE,
};
use crate::{Error, Result};
use axum::extract::{Path, Query};
use axum::Json;
use log::info;
use serde::Deserialize;
use utoipa::OpenApi;

#[derive(Deserialize)]
pub struct FollowsQuery {
    skip: Option<usize>,
    limit: Option<usize>,
}

#[utoipa::path(
    get,
    path = USER_FOLLOWERS_ROUTE,
    tag = "User Followers List",
    params(
        ("user_id" = String, Path, description = "User Pubky ID"),
        ("skip" = Option<usize>, Query, description = "Skip N followers"),
        ("limit" = Option<usize>, Query, description = "Retrieve N followers")
    ),
    responses(
        (status = 200, description = "User followers list", body = Followers),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn user_followers_handler(
    Path(user_id): Path<String>,
    Query(query): Query<FollowsQuery>,
) -> Result<Json<Followers>> {
    info!("GET {USER_FOLLOWERS_ROUTE} user_id:{}", user_id);

    let skip = query.skip.unwrap_or(0);
    let limit = query.limit.unwrap_or(200);

    match Followers::get_by_id(&user_id, Some(skip), Some(limit)).await {
        Ok(Some(followers)) => Ok(Json(followers)),
        Ok(None) => Err(Error::UserNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[utoipa::path(
    get,
    path = USER_FOLLOWING_ROUTE,
    tag = "User Following List",
    params(
        ("user_id" = String, Path, description = "User Pubky ID"),
        ("skip" = Option<usize>, Query, description = "Skip N following"),
        ("limit" = Option<usize>, Query, description = "Retrieve N following")
    ),
    responses(
        (status = 200, description = "User following list", body = Following),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn user_following_handler(
    Path(user_id): Path<String>,
    Query(query): Query<FollowsQuery>,
) -> Result<Json<Following>> {
    info!("GET {USER_FOLLOWING_ROUTE} user_id:{}", user_id);

    let skip = query.skip.unwrap_or(0);
    let limit = query.limit.unwrap_or(200);

    match Following::get_by_id(&user_id, Some(skip), Some(limit)).await {
        Ok(Some(following)) => Ok(Json(following)),
        Ok(None) => Err(Error::UserNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[utoipa::path(
    get,
    path = USER_FRIENDS_ROUTE,
    tag = "User Friends List",
    params(
        ("user_id" = String, Path, description = "User Pubky ID"),
        ("skip" = Option<usize>, Query, description = "Skip N friends"),
        ("limit" = Option<usize>, Query, description = "Retrieve N friends")
    ),
    responses(
        (status = 200, description = "User friends list", body = Friends),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn user_friends_handler(
    Path(user_id): Path<String>,
    Query(query): Query<FollowsQuery>,
) -> Result<Json<Friends>> {
    info!("GET {USER_FRIENDS_ROUTE} user_id:{}", user_id);

    let skip = query.skip.unwrap_or(0);
    let limit = query.limit.unwrap_or(200);

    match Friends::get_by_id(&user_id, Some(skip), Some(limit)).await {
        Ok(Some(friends)) => Ok(Json(friends)),
        Ok(None) => Err(Error::UserNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(
    paths(user_followers_handler, user_following_handler, user_friends_handler),
    components(schemas(Followers, Following, Friends))
)]
pub struct UserFollowsApiDoc;
```
./src/routes/v0/user/relationship.rs
```
use crate::models::user::Relationship;
use crate::routes::v0::endpoints::RELATIONSHIP_ROUTE;
use crate::{Error, Result};
use axum::extract::Path;
use axum::Json;
use log::info;
use utoipa::OpenApi;

#[utoipa::path(
    get,
    path = RELATIONSHIP_ROUTE,
    tag = "User <> Viewer Relationship",
    params(
        ("user_id" = String, Path, description = "User Pubky ID"),
        ("viewer_id" = String, Path, description = "Viewer Pubky ID")
    ),
    responses(
        (status = 200, description = "User relationship", body = Relationship),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn user_relationship_handler(
    Path((user_id, viewer_id)): Path<(String, String)>,
) -> Result<Json<Relationship>> {
    info!(
        "GET {RELATIONSHIP_ROUTE} user_id:{}, viewer_id:{}",
        user_id, viewer_id
    );

    match Relationship::get_by_id(&user_id, Some(&viewer_id)).await {
        Ok(Some(relationship)) => Ok(Json(relationship)),
        Ok(None) => Err(Error::UserNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(paths(user_relationship_handler), components(schemas(Relationship)))]
pub struct RelationshipApiDoc;
```
./src/routes/v0/user/tags.rs
```
use crate::models::tag::user::{UserTag, UserTags};
use crate::models::tag::{Tag, Tags};
use crate::routes::v0::endpoints::USER_TAGS_ROUTE;
use crate::{Error, Result};
use axum::extract::Path;
use axum::Json;
use log::info;
use utoipa::OpenApi;

#[utoipa::path(
    get,
    path = USER_TAGS_ROUTE,
    tag = "User Tags",
    params(
        ("user_id" = String, Path, description = "User Pubky ID")
    ),
    responses(
        (status = 200, description = "User tags", body = UserTags),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn user_tags_handler(Path(user_id): Path<String>) -> Result<Json<UserTags>> {
    info!("GET {USER_TAGS_ROUTE} user_id:{}", user_id);

    match UserTags::get_by_id(&user_id).await {
        Ok(Some(tags)) => Ok(Json(tags)),
        Ok(None) => Err(Error::UserNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(
    paths(user_tags_handler),
    components(schemas(UserTags, UserTag, Tags, Tag))
)]
pub struct UserTagsApiDoc;
```
./src/routes/v0/user/mod.rs
```
use crate::register_routes;
use crate::routes::v0::endpoints;
use axum::Router;
use utoipa::OpenApi;

mod counts;
mod details;
mod follows;
mod relationship;
mod tags;
mod view;

pub fn routes() -> Router {
    register_routes!(Router::new(),
        endpoints::USER_ROUTE => view::user_view_handler,
        endpoints::USER_DETAILS_ROUTE => details::user_details_handler,
        endpoints::RELATIONSHIP_ROUTE => relationship::user_relationship_handler,
        endpoints::USER_TAGS_ROUTE => tags::user_tags_handler,
        endpoints::USER_COUNTS_ROUTE => counts::user_counts_handler,
        endpoints::USER_FOLLOWERS_ROUTE => follows::user_followers_handler,
        endpoints::USER_FOLLOWING_ROUTE => follows::user_following_handler,
        endpoints::USER_FRIENDS_ROUTE => follows::user_friends_handler,
    )
}

#[derive(OpenApi)]
#[openapi()]
pub struct UserApiDoc;

impl UserApiDoc {
    pub fn merge_docs() -> utoipa::openapi::OpenApi {
        let mut combined = view::UserViewApiDoc::openapi();
        combined.merge(counts::UserCountsApiDoc::openapi());
        combined.merge(details::UserDetailsApiDoc::openapi());
        combined.merge(relationship::RelationshipApiDoc::openapi());
        combined.merge(tags::UserTagsApiDoc::openapi());
        combined.merge(follows::UserFollowsApiDoc::openapi());
        combined
    }
}
```
./src/routes/v0/user/details.rs
```
use crate::models::user::{UserDetails, UserLink};
use crate::routes::v0::endpoints::USER_DETAILS_ROUTE;
use crate::{Error, Result};
use axum::extract::Path;
use axum::Json;
use log::info;
use utoipa::OpenApi;

#[utoipa::path(
    get,
    path = USER_DETAILS_ROUTE,
    tag = "User Details",
    params(
        ("user_id" = String, Path, description = "User Pubky ID")
    ),
    responses(
        (status = 200, description = "User details", body = UserDetails),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn user_details_handler(Path(user_id): Path<String>) -> Result<Json<UserDetails>> {
    info!("GET {USER_DETAILS_ROUTE} user_id:{}", user_id);

    match UserDetails::get_by_id(&user_id).await {
        Ok(Some(details)) => Ok(Json(details)),
        Ok(None) => Err(Error::UserNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(
    paths(user_details_handler),
    components(schemas(UserDetails, UserLink))
)]
pub struct UserDetailsApiDoc;
```
./src/routes/v0/user/counts.rs
```
use crate::models::user::UserCounts;
use crate::routes::v0::endpoints::USER_COUNTS_ROUTE;
use crate::{Error, Result};
use axum::extract::Path;
use axum::Json;
use log::info;
use utoipa::OpenApi;

#[utoipa::path(
    get,
    path = USER_COUNTS_ROUTE,
    tag = "User Counts",
    params(
        ("user_id" = String, Path, description = "User Pubky ID")
    ),
    responses(
        (status = 200, description = "User counts", body = UserCounts),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn user_counts_handler(Path(user_id): Path<String>) -> Result<Json<UserCounts>> {
    info!("GET {USER_COUNTS_ROUTE} user_id:{}", user_id);

    match UserCounts::get_by_id(&user_id).await {
        Ok(Some(counts)) => Ok(Json(counts)),
        Ok(None) => Err(Error::UserNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(paths(user_counts_handler), components(schemas(UserCounts)))]
pub struct UserCountsApiDoc;
```
./src/routes/v0/user/view.rs
```
use crate::models::tag::user::UserTags;
use crate::models::tag::{Tag, Tags};
use crate::models::user::UserView;
use crate::routes::v0::endpoints::USER_ROUTE;
use crate::{Error, Result};
use axum::extract::{Path, Query};
use axum::Json;
use log::info;
use serde::Deserialize;
use utoipa::OpenApi;

#[derive(Deserialize)]
pub struct ProfileQuery {
    viewer_id: Option<String>,
}

#[utoipa::path(
    get,
    path = USER_ROUTE,
    tag = "User Profile",
    params(
        ("user_id" = String, Path, description = "User Pubky ID"),
        ("viewer_id" = Option<String>, Query, description = "Viewer Pubky ID")
    ),
    responses(
        (status = 200, description = "User Profile", body = UserView),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn user_view_handler(
    Path(user_id): Path<String>,
    Query(query): Query<ProfileQuery>,
) -> Result<Json<UserView>> {
    info!(
        "GET {USER_ROUTE} user_id:{}, viewer_id:{:?}",
        user_id, query.viewer_id
    );

    match UserView::get_by_id(&user_id, query.viewer_id.as_deref()).await {
        Ok(Some(user)) => Ok(Json(user)),
        Ok(None) => Err(Error::UserNotFound { user_id }),
        Err(source) => Err(Error::InternalServerError { source }),
    }
}

#[derive(OpenApi)]
#[openapi(
    paths(user_view_handler),
    components(schemas(UserView, UserTags, Tags, Tag))
)]
pub struct UserViewApiDoc;
```
./src/routes/v0/info.rs
```
use super::endpoints::INFO_ROUTE;
use crate::models::info::ServerInfo;
use crate::register_routes;
use axum::response::IntoResponse;
use axum::{Json, Router};
use utoipa::OpenApi;

#[utoipa::path(
    get,
    path = INFO_ROUTE,
    tag = "Service Info",
    responses(
        (status = 200, description = "Server info", body = ServerInfo)
    )
)]
pub async fn info_handler() -> impl IntoResponse {
    let info = ServerInfo::new().await;
    Json(info)
}

pub fn routes() -> Router {
    register_routes!(Router::new(), super::endpoints::INFO_ROUTE => info_handler)
}

#[derive(OpenApi)]
#[openapi(paths(info_handler), components(schemas(ServerInfo)))]
pub struct InfoApiDoc;
```
./src/watcher.rs
```
// TODO: Research if that one is the best approach
// Maybe here we can create an POST endpoint that fakes the event stream
// After with mpsc (Multiple Producer Single Consumer) broadcast the event
// to all consumers. In our case, graph and kv
fn main() {
    println!("Hello, world! This is where the homeserver(s) watcher will be in the future.");
}
```
./src/db/kv/mod.rs
```
pub mod flush;
pub mod index;
pub mod last_save;
pub mod traits;
```
./src/db/kv/traits.rs
```
use super::index::*;
use axum::async_trait;
use serde::{de::DeserializeOwned, Serialize};
use sorted_sets::Sorting;
use std::error::Error;

/// A trait for operations involving Redis storage. Implement this trait for types that need to be stored
/// and retrieved from Redis with serialization and deserialization capabilities.
#[async_trait]
pub trait RedisOps: Serialize + DeserializeOwned + Send + Sync {
    /// Provides a prefix string for the Redis key.
    ///
    /// This method should return a prefix string that helps namespace the keys in Redis,
    /// preventing key collisions. The prefix is typically derived from the struct name.
    ///
    /// # Returns
    ///
    /// A `String` representing the prefix for Redis keys.
    async fn prefix() -> String {
        let type_name = std::any::type_name::<Self>();
        let struct_name = type_name.split("::").last().unwrap_or_default();

        // Insert ":" before each uppercase letter except the first one
        let mut prefixed_name = String::new();
        let chars = struct_name.chars().peekable();

        for c in chars {
            if c.is_uppercase() && !prefixed_name.is_empty() {
                prefixed_name.push(':');
            }
            prefixed_name.push(c);
        }

        prefixed_name
    }

    /// Sets the data in Redis using the provided key parts.
    ///
    /// This method serializes the data and stores it in Redis under the key generated
    /// from the provided `key_parts`. It can also set an expiration time for the key if required.
    ///
    /// # Arguments
    ///
    /// * `key_parts` - A slice of string slices that represent the parts used to form the key under which the value is stored.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails, such as if the Redis connection is unavailable.
    async fn put_index_json(&self, key_parts: &[&str]) -> Result<(), Box<dyn Error + Send + Sync>> {
        json::put(
            &Self::prefix().await,
            &key_parts.join(":"),
            self,
            None,
            None,
        )
        .await
    }

    /// Stores multiple key-value pairs in Redis, where each key is constructed from the provided key parts
    /// and each value is an item from the given collection.
    ///
    /// This method serializes each item in the collection and stores it in Redis under keys generated
    /// by joining the elements of the corresponding slices in `key_parts_list`. It efficiently handles
    /// the setting of multiple key-value pairs in a single operation.
    ///
    /// # Arguments
    ///
    /// * `key_parts_list` - A slice of slices, where each inner slice is a list of string slices representing
    ///   the components used to generate the Redis key for the corresponding value in the `collection`.
    ///   Each slice in this list must align with the corresponding index in `collection`.
    ///
    /// * `collection` - A vector of `Option<Self>` representing the values to be stored in Redis. Each value is serialized
    ///   before being stored, and the vector should be of the same length as `key_parts_list`.
    ///
    /// # Returns
    ///
    /// This function returns a `Result` indicating success or failure. A successful result means that
    /// all key-value pairs were successfully stored in Redis.
    async fn put_multiple_json_indexes(
        key_parts_list: &[&[&str]],
        collection: Vec<Option<Self>>,
    ) -> Result<(), Box<dyn Error + Send + Sync>> // The items in the collection must be serializable
    {
        let mut data = Vec::with_capacity(key_parts_list.len());
        for (i, key_parts) in key_parts_list.iter().enumerate() {
            let key = key_parts.join(":");
            data.push((key, &collection[i]));
        }

        json::put_multiple(&Self::prefix().await, &data).await
    }

    /// Adds elements to a Redis list using the provided key parts.
    ///
    /// This method serializes the data and appends it to a Redis list under the key generated
    /// from the provided `key_parts`.
    ///
    /// # Arguments
    ///
    /// * `key_parts` - A slice of string slices that represent the parts used to form the key under which the list is stored.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails, such as if the Redis connection is unavailable or
    /// if there is an issue with serialization.
    async fn put_index_list<T>(
        &self,
        key_parts: &[&str],
    ) -> Result<(), Box<dyn Error + Send + Sync>>
    where
        Self: AsRef<[T]>,            // Self can be dereferenced into a slice of T
        T: AsRef<str> + Send + Sync, // The items must be convertible to &str
    {
        let prefix = Self::prefix().await;
        let key = key_parts.join(":");

        // TODO: Unsafe. If re-indexed it will duplicate follower/following list entries.
        // Need reading, matching out the duplicates then storing. Inneficient.
        // Needs mode safety for double-write.

        // Directly use the string representations of items without additional serialization
        let collection = self.as_ref();
        let values: Vec<&str> = collection.iter().map(|item| item.as_ref()).collect();

        // Store the values in the Redis list
        lists::put(&prefix, &key, &values).await
    }

    /// Adds elements to a Redis set using the provided key parts.
    ///
    /// This method adds elements to a Redis set under the key generated from the provided `key_parts`.
    /// It ensures that each element in the set is unique.
    ///
    /// # Arguments
    ///
    /// * `key_parts` - A slice of string slices that represent the parts used to form the key under which the set is stored.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails, such as if the Redis connection is unavailable or
    /// if there is an issue with serialization.
    async fn put_index_set<T>(&self, key_parts: &[&str]) -> Result<(), Box<dyn Error + Send + Sync>>
    where
        Self: AsRef<[T]>,            // Self can be dereferenced into a slice of T
        T: AsRef<str> + Send + Sync, // The items must be convertible to &str
    {
        let prefix = Self::prefix().await;
        let key = key_parts.join(":");

        // Directly use the string representations of items without additional serialization
        let collection = self.as_ref();
        let values: Vec<&str> = collection.iter().map(|item| item.as_ref()).collect();

        // Store the values in the Redis set
        sets::put(&prefix, &key, &values).await
    }

    /// Retrieves data from Redis using the provided key parts.
    ///
    /// This method deserializes the data stored under the key generated from the provided `key_parts` in Redis.
    /// If the key is not found, it returns `None`.
    ///
    /// # Arguments
    ///
    /// * `key_parts` - A slice of string slices that represent the parts used to form the key under which the value is stored.
    ///
    /// # Returns
    ///
    /// An `Option<Self>` containing the deserialized data if found, or `None` if the key does not exist.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails, such as if the Redis connection is unavailable.
    async fn try_from_index_json(
        key_parts: &[&str],
    ) -> Result<Option<Self>, Box<dyn Error + Send + Sync>> {
        json::get(&Self::prefix().await, &key_parts.join(":"), None).await
    }

    /// Retrieves multiple JSON objects from Redis using the provided key parts.
    ///
    /// This method deserializes the data stored under the keys generated from the provided `key_parts_list` in Redis.
    /// It returns a vector of options, where each option corresponds to the existence of the key in Redis.
    ///
    /// # Arguments
    ///
    /// * `key_parts_list` - A slice of slices, where each inner slice contains string slices representing
    ///   the parts used to form the key under which the corresponding value is stored.
    ///
    /// # Returns
    ///
    /// A `Vec<Option<Self>>` containing the deserialized data if found, or `None` if a key does not exist.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails, such as if the Redis connection is unavailable.
    async fn try_from_index_multiple_json(
        key_parts_list: &[&[&str]],
    ) -> Result<Vec<Option<Self>>, Box<dyn Error + Send + Sync>> {
        let prefix = Self::prefix().await;
        let keys: Vec<String> = key_parts_list
            .iter()
            .map(|key_parts| key_parts.join(":"))
            .collect();

        json::get_multiple(&prefix, &keys, None).await
    }

    /// Retrieves a range of elements from a Redis list using the provided key parts.
    ///
    /// This method fetches elements from a Redis list stored under the key generated from the provided `key_parts`.
    /// The range is defined by `skip` and `limit` parameters.
    ///
    /// # Arguments
    ///
    /// * `key_parts` - A slice of string slices that represent the parts used to form the key under which the list is stored.
    /// * `skip` - An optional number of elements to skip (useful for pagination).
    /// * `limit` - An optional number of elements to return (useful for pagination).
    ///
    /// # Returns
    ///
    /// Returns a vector of deserialized elements if they exist, or an empty vector if no matching elements are found.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails, such as if the Redis connection is unavailable.
    async fn try_from_index_list(
        key_parts: &[&str],
        skip: Option<usize>,
        limit: Option<usize>,
    ) -> Result<Option<Vec<String>>, Box<dyn Error + Send + Sync>> {
        let prefix = Self::prefix().await;
        let key = key_parts.join(":");
        lists::get_range(&prefix, &key, skip, limit).await
    }

    /// Retrieves a range of elements from a Redis set using the provided key parts.
    ///
    /// This method fetches elements from a Redis set stored under the key generated from the provided `key_parts`.
    /// The range is defined by `skip` and `limit` parameters.
    ///
    /// # Arguments
    ///
    /// * `key_parts` - A slice of string slices that represent the parts used to form the key under which the set is stored.
    /// * `skip` - An optional number of elements to skip (useful for pagination).
    /// * `limit` - An optional number of elements to return (useful for pagination).
    ///
    /// # Returns
    ///
    /// Returns a vector of deserialized elements if they exist, or an empty vector if no matching elements are found.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails, such as if the Redis connection is unavailable.
    async fn try_from_index_set(
        key_parts: &[&str],
        skip: Option<usize>,
        limit: Option<usize>,
    ) -> Result<Option<Vec<String>>, Box<dyn Error + Send + Sync>> {
        let prefix = Self::prefix().await;
        let key = key_parts.join(":");
        sets::get_range(&prefix, &key, skip, limit).await
    }

    /// Checks if a member exists in a Redis set and if the set exists using the provided key parts.
    ///
    /// This method checks if a specific member is present in the Redis set stored under the key
    /// generated from the provided `key_parts`. It also determines if the set itself exists.
    ///
    /// # Arguments
    ///
    /// * `key_parts` - A slice of string slices that represent the parts used to form the key under which the set is stored.
    /// * `member` - A string slice representing the member to check for existence in the set.
    ///
    /// # Returns
    ///
    /// Returns `Ok((true, true))` if the set exists and the member is in the set,
    /// `Ok((true, false))` if the set exists but the member is not in the set,
    /// `Ok((false, false))` if the set does not exist.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails, such as if the Redis connection is unavailable.
    async fn check_set_member(
        key_parts: &[&str],
        member: &str,
    ) -> Result<(bool, bool), Box<dyn Error + Send + Sync>> {
        let prefix = Self::prefix().await;
        let key = key_parts.join(":");
        sets::check_set_member(&prefix, &key, member).await
    }

    /// Adds elements to a Redis sorted set using the provided key parts.
    ///
    /// This method adds elements to a Redis sorted set under the key generated from the provided `key_parts`.
    /// The elements are associated with scores, which determine their order in the set.
    ///
    /// # Arguments
    ///
    /// * `key_parts` - A slice of string slices that represent the parts used to form the key under which the sorted set is stored.
    /// * `elements` - A slice of tuples where each tuple contains a reference to a string slice representing
    ///                the element and a f64 representing the score of the element.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails, such as if the Redis connection is unavailable.
    async fn put_index_sorted_set(
        key_parts: &[&str],
        elements: &[(f64, &str)],
    ) -> Result<(), Box<dyn Error + Send + Sync>> {
        let key = key_parts.join(":");
        // Store the elements in the Redis sorted set
        sorted_sets::put("Sorted", &key, elements).await
    }

    /// Retrieves a range of elements from a Redis sorted set using the provided key parts.
    ///
    /// This method fetches elements from a Redis sorted set stored under the key generated from the provided `key_parts`.
    /// The range is defined by `skip` and `limit` parameters.
    ///
    /// # Arguments
    ///
    /// * `key_parts` - A slice of string slices that represent the parts used to form the key under which the sorted set is stored.
    /// * `skip` - An optional number of elements to skip (useful for pagination).
    /// * `limit` - An optional number of elements to return (useful for pagination).
    ///
    /// # Returns
    ///
    /// Returns a vector of tuples containing the elements and their scores if they exist, or an empty vector if no matching elements are found.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails, such as if the Redis connection is unavailable.
    async fn try_from_index_sorted_set(
        key_parts: &[&str],
        start: Option<f64>,
        end: Option<f64>,
        skip: Option<usize>,
        limit: Option<usize>,
        sorting: Sorting,
    ) -> Result<Option<Vec<(String, f64)>>, Box<dyn Error + Send + Sync>> {
        let key = key_parts.join(":");
        sorted_sets::get_range("Sorted", &key, start, end, skip, limit, sorting).await
    }
}
```
./src/db/kv/flush.rs
```
use crate::db::connectors::redis::get_redis_conn;
use std::error::Error;

pub async fn clear_redis() -> Result<(), Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;
    redis::cmd("FLUSHDB").query_async(&mut redis_conn).await?;
    Ok(())
}
```
./src/db/kv/last_save.rs
```
use crate::db::connectors::redis::get_redis_conn;
use std::error::Error;

pub async fn get_last_rdb_save_time() -> Result<u64, Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;
    let info: String = redis::cmd("INFO")
        .arg("persistence")
        .query_async(&mut redis_conn)
        .await?;
    for line in info.lines() {
        if line.starts_with("rdb_last_save_time:") {
            if let Some(value_str) = line.split(':').nth(1) {
                let timestamp = value_str.trim().parse::<u64>()?;
                return Ok(timestamp);
            }
        }
    }
    Err("Could not find rdb_last_save_time in the info output".into())
}
```
./src/db/kv/index/sorted_sets.rs
```
use crate::db::connectors::redis::get_redis_conn;
use redis::AsyncCommands;
use std::error::Error;

pub enum Sorting {
    Ascending,
    Descending,
}
/// Adds elements to a Redis sorted set.
///
/// This function adds elements to the specified Redis sorted set. If the set doesn't exist,
/// it creates a new sorted set.
///
/// # Argumentsf64
///
/// * `prefix` - A string slice representing the prefix for the Redis keys.
/// * `key` - A string slice representing the key under which the sorted set is stored.
/// * `values` - A slice of tuples where each tuple contains a reference to a string slice representing
///              the element and a f64 representing the score of the element.
///
/// # Errors
///
/// Returns an error if the operation fails.
pub async fn put(
    prefix: &str,
    key: &str,
    items: &[(f64, &str)],
) -> Result<(), Box<dyn Error + Send + Sync>> {
    if items.is_empty() {
        return Ok(());
    }

    let index_key = format!("{}:{}", prefix, key);
    let mut redis_conn = get_redis_conn().await?;

    redis_conn.zadd_multiple(&index_key, items).await?;

    Ok(())
}

/// Retrieves a range of elements from a Redis sorted set.
///
/// This function retrieves elements from a specified Redis sorted set based on a score range.
/// The range is defined by `min_score` and `max_score` parameters, where `min_score` and `max_score`
/// specify the inclusive lower and upper bounds of the scores.
///
/// # Arguments
///
/// * `prefix` - A string slice representing the prefix for the Redis keys.
/// * `key` - A string slice representing the key under which the sorted set is stored.
/// * `min_score` - The minimum score for the range (inclusive).
/// * `max_score` - The maximum score for the range (inclusive).
/// * `limit` - The maximum number of elements to retrieve.
/// * `sorting` - The sorting order (ascending or descending).
///
/// # Returns
///
/// Returns a vector of tuples containing the elements and their scores.
///
/// # Errors
///
/// Returns an error if the operation fails.
pub async fn get_range(
    prefix: &str,
    key: &str,
    min_score: Option<f64>,
    max_score: Option<f64>,
    skip: Option<usize>,
    limit: Option<usize>,
    sorting: Sorting,
) -> Result<Option<Vec<(String, f64)>>, Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;
    let index_key = format!("{}:{}", prefix, key);

    let min_score = min_score.unwrap_or(f64::MIN);
    let max_score = max_score.unwrap_or(f64::MAX);
    let skip = skip.unwrap_or(0) as isize;
    let limit = limit.unwrap_or(1000) as isize;

    // ZRANGE with the WITHSCORES option retrieves both: the elements and their scores
    let elements: Vec<(String, f64)> = match sorting {
        Sorting::Ascending => {
            redis_conn
                .zrangebyscore_limit_withscores(index_key, min_score, max_score, skip, limit)
                .await?
        }
        Sorting::Descending => {
            redis_conn
                .zrevrangebyscore_limit_withscores(index_key, max_score, min_score, skip, limit)
                .await?
        }
    };

    match elements.len() {
        0 => Ok(None),
        _ => Ok(Some(elements)),
    }
}
```
./src/db/kv/index/mod.rs
```
/// Module for redis Indexing operations split into modules by Redis types
pub mod json;
pub mod lists;
pub mod sets;
pub mod sorted_sets;
```
./src/db/kv/index/sets.rs
```
use crate::db::connectors::redis::get_redis_conn;
use redis::AsyncCommands;
use std::error::Error;

/// Adds elements to a Redis set.
///
/// This function adds elements to the specified Redis set. If the set doesn't exist,
/// it creates a new set.
///
/// # Arguments
///
/// * `prefix` - A string slice representing the prefix for the Redis keys.
/// * `key` - A string slice representing the key under which the set is stored.
/// * `values` - A slice of string slices representing the elements to be added to the set.
///
/// # Errors
///
/// Returns an error if the operation fails.
pub async fn put(
    prefix: &str,
    key: &str,
    values: &[&str],
) -> Result<(), Box<dyn Error + Send + Sync>> {
    if values.is_empty() {
        return Ok(());
    }
    let index_key = format!("{}:{}", prefix, key);
    let mut redis_conn = get_redis_conn().await?;
    redis_conn.sadd(index_key, values).await?;
    Ok(())
}

/// Retrieves a range of elements from a Redis set.
///
/// This function retrieves elements from a specified Redis set using a cursor-based approach.
/// The range is defined by `skip` and `limit` parameters, where `skip` indicates the number
/// of elements to skip and `limit` specifies the number of elements to retrieve.
///
/// # Arguments
///
/// * `prefix` - A string slice representing the prefix for the Redis keys.
/// * `key` - A string slice representing the key under which the set is stored.
/// * `skip` - The number of elements to skip.
/// * `limit` - The number of elements to retrieve from the set after the skip.
///
/// # Returns
///
/// Returns a vector of strings containing the retrieved elements.
///
/// # Errors
///
/// Returns an error if the operation fails.
pub async fn get_range(
    prefix: &str,
    key: &str,
    skip: Option<usize>,
    limit: Option<usize>,
) -> Result<Option<Vec<String>>, Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;

    let index_key = format!("{}:{}", prefix, key);
    let mut cursor = "0".to_string();
    let mut collected: Vec<String> = Vec::new();
    let skip = skip.unwrap_or(0);
    let limit = limit.unwrap_or(5);

    let mut skipped = 0;

    while collected.len() < limit {
        let result: (String, Vec<String>) = redis::cmd("SSCAN")
            .arg(&index_key)
            .arg(&cursor)
            .arg("COUNT")
            .arg(limit)
            .query_async(&mut redis_conn)
            .await?;

        let (new_cursor, items) = result;

        for item in items {
            if skipped < skip {
                skipped += 1;
                continue;
            }
            collected.push(item);
            if collected.len() >= limit {
                break;
            }
        }

        cursor = new_cursor;
        if cursor == "0" {
            break; // End of the set reached
        }
    }

    if collected.is_empty() {
        Ok(None)
    } else {
        Ok(Some(collected))
    }
}

/// Checks if a member exists in a Redis set and if the set exists.
///
/// This function checks if the specified `member` exists within the Redis set identified
/// by the combined `prefix` and `key`, and whether the set itself exists.
///
/// # Arguments
///
/// * `prefix` - A string slice representing the prefix for the Redis keys.
/// * `key` - A string slice representing the key under which the set is stored.
/// * `member` - A string slice representing the member to check for existence in the set.
///
/// # Returns
///
/// Returns `Ok((true, true))` if the set exists and the member is in the set,
/// `Ok((true, false))` if the set exists but the member is not in the set,
/// `Ok((false, false))` if the set does not exist.
///
/// Returns an error if the operation fails, such as if the Redis connection is unavailable.
pub async fn check_set_member(
    prefix: &str,
    key: &str,
    member: &str,
) -> Result<(bool, bool), Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;
    let index_key = format!("{}:{}", prefix, key);

    // Check if the set exists
    let set_exists: bool = redis_conn.exists(&index_key).await?;

    if set_exists {
        // Check if the member exists in the set
        let is_member: bool = redis_conn.sismember(&index_key, member).await?;
        Ok((true, is_member))
    } else {
        Ok((false, false))
    }
}
```
./src/db/kv/index/lists.rs
```
use crate::db::connectors::redis::get_redis_conn;
use redis::AsyncCommands;
use std::error::Error;

/// Adds elements to a Redis list.
///
/// This function appends elements to the specified Redis list. If the list doesn't exist,
/// it creates a new list.
///
/// # Arguments
///
/// * `prefix` - A string slice representing the prefix for the Redis keys.
/// * `key` - A string slice representing the key under which the list is stored.
/// * `values` - A slice of string slices representing the elements to be added to the list.
///
/// # Errors
///
/// Returns an error if the operation fails.
pub async fn put(
    prefix: &str,
    key: &str,
    values: &[&str],
) -> Result<(), Box<dyn Error + Send + Sync>> {
    if values.is_empty() {
        return Ok(());
    }
    let index_key = format!("{}:{}", prefix, key);
    let mut redis_conn = get_redis_conn().await?;
    redis_conn.rpush(index_key, values).await?;
    Ok(())
}

/// Retrieves a range of elements from a Redis list.
///
/// This function retrieves elements from a specified Redis list within a given range.
/// The range is defined by `skip` and `limit` parameters.
///
/// # Arguments
///
/// * `prefix` - A string slice representing the prefix for the Redis keys.
/// * `key` - A string slice representing the key under which the list is stored.
/// * `skip` - The number of elements to skip from the beginning of the list.
/// * `limit` - The number of elements to retrieve from the list after the skip.
///
/// # Returns
///
/// Returns a vector of strings containing the retrieved elements.
///
/// # Errors
///
/// Returns an error if the operation fails.
pub async fn get_range(
    prefix: &str,
    key: &str,
    skip: Option<usize>,
    limit: Option<usize>,
) -> Result<Option<Vec<String>>, Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;

    let index_key = format!("{}:{}", prefix, key);
    let skip = skip.unwrap_or(0);
    let limit = limit.unwrap_or(usize::MAX);

    let start = skip as isize;
    let end = start + (limit as isize) - 1;
    let result: Vec<String> = redis_conn.lrange(index_key, start, end).await?;
    match result.len() {
        0 => Ok(None),
        _ => Ok(Some(result)),
    }
}
```
./src/db/kv/index/json.rs
```
use crate::db::connectors::redis::get_redis_conn;
use log::debug;
use redis::{AsyncCommands, JsonAsyncCommands};
use serde::{de::DeserializeOwned, Serialize};
use std::error::Error;

/// Sets a value in Redis, supporting both JSON objects and boolean values.
///
/// This function stores JSON objects using RedisJSON and booleans as integers (0 or 1).
/// An optional expiration time can be set for both types.
///
/// # Arguments
///
/// * `prefix` - A string slice representing the prefix for the Redis key.
/// * `key` - A string slice representing the key under which the value is stored.
/// * `value` - A reference to the value to be stored. If the value is a boolean, it will be stored as 0 or 1. For other types, it must implement `Serialize`.
/// * `path` - An optional string slice representing the JSON path where the value should be set for JSON objects. Defaults to the root path "$".
/// * `expiration` - An optional expiration time in seconds. If provided, the key will expire after this duration.
///
/// # Errors
///
/// Returns an error if the operation fails.
pub async fn put<T: Serialize + Send + Sync>(
    prefix: &str,
    key: &str,
    value: &T,
    path: Option<&str>,
    expiration: Option<i64>,
) -> Result<(), Box<dyn Error + Send + Sync>> {
    let index_key = format!("{}:{}", prefix, key);

    match serde_json::to_value(value)? {
        serde_json::Value::Bool(boolean_value) => {
            handle_put_boolean(&index_key, boolean_value, expiration).await?;
        }
        _ => {
            handle_put_json(&index_key, value, path, expiration).await?;
        }
    }

    debug!(
        "Set key: {} with optional expiration: {:?}",
        index_key, expiration
    );
    Ok(())
}

async fn handle_put_boolean(
    key: &str,
    value: bool,
    expiration: Option<i64>,
) -> Result<(), Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;

    let int_value = if value { 1 } else { 0 };
    if let Some(exp) = expiration {
        redis_conn.set_ex(key, int_value, exp as u64).await?;
    } else {
        redis_conn.set(key, int_value).await?;
    }
    Ok(())
}

async fn handle_put_json<T: Serialize + Send + Sync>(
    key: &str,
    value: &T,
    path: Option<&str>,
    expiration: Option<i64>,
) -> Result<(), Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;

    let json_path = path.unwrap_or("$");
    redis_conn.json_set(key, json_path, value).await?;
    if let Some(exp) = expiration {
        redis_conn.expire(key, exp).await?;
    }
    Ok(())
}

/// Sets a list of keys and their corresponding values in Redis in a single operation.
///
/// This function handles both JSON and boolean values, using RedisJSON for JSON data and storing booleans
/// as integers. It uses multiple commands in a single request to set key-value pairs efficiently.
/// Each value must implement the `Serialize` trait for JSON or be a boolean.
///
/// # Arguments
///
/// * `prefix` - A string slice representing the prefix for the Redis keys.
/// * `data` - A slice of tuples where each tuple contains a key as a string slice and a value that implements `Serialize`.
///
/// # Returns
///
/// Returns a `Result` indicating success or an error if the operation fails.
///
/// # Errors
///
/// This function will return an error if there are issues connecting to Redis, or if serialization of the values fails.
///
/// # Examples
///
/// ```ignore
/// use serde::Serialize;
///
/// #[derive(Serialize)]
/// struct MyValue {
///     field1: String,
///     field2: i32,
/// }
///
/// let data = vec![
///     ("key1", MyValue { field1: "value1".to_string(), field2: 10 }),
///     ("key2", MyValue { field1: "value2".to_string(), field2: 20 }),
///     ("key3", true), // boolean value
/// ];
///
/// put_multiple::<MyValue>("prefix:", &data).await?;
/// ```
///
/// This example sets multiple key-value pairs with a common prefix in Redis.
pub async fn put_multiple<T: Serialize>(
    prefix: &str,
    data: &[(impl AsRef<str>, T)],
) -> Result<(), Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;

    // Create a pipeline-like command sequence
    let mut cmd = redis::pipe();

    for (key, value) in data {
        let full_key = format!("{}:{}", prefix, key.as_ref());

        // Check if the value is boolean
        match serde_json::to_value(value)? {
            serde_json::Value::Bool(boolean_value) => {
                let int_value = if boolean_value { 1 } else { 0 };
                cmd.set(&full_key, int_value);
            }
            _ => {
                // Handle other values as JSON
                cmd.json_set(&full_key, "$", value)?;
            }
        }
    }

    cmd.query_async(&mut redis_conn).await?;
    Ok(())
}

/// Retrieves a JSON value from Redis at a specified path.
///
/// # Arguments
///
/// * `prefix` - A string slice that represents the prefix for the Redis key.
/// * `key` - A string slice that represents the key under which the value is stored.
/// * `path` - An optional string slice representing the JSON path from which the value should be retrieved. Defaults to the root path "$".
///
/// # Returns
///
/// Returns an `Option` containing the retrieved value if it exists, or `None` if it does not.
///
/// # Errors
///
/// Returns an error if the operation fails.
pub async fn get<T: DeserializeOwned + Send + Sync>(
    prefix: &str,
    key: &str,
    path: Option<&str>,
) -> Result<Option<T>, Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;
    let index_key = format!("{}:{}", prefix, key);
    let json_path = path.unwrap_or("$").to_string(); // Ensure path is a String

    // Use RedisJSON commands to get the value from the specified path
    if let Ok(indexed_value) = redis_conn
        .json_get::<String, String, String>(index_key.clone(), json_path)
        .await
    {
        debug!("Restored key: {} with value: {}", index_key, indexed_value);
        let value: Vec<T> = serde_json::from_str(&indexed_value)?;
        return Ok(value.into_iter().next()); // Extract the first element from the Vec
    }

    Ok(None)
}

/// Retrieves a list of JSON values from Redis based on a list of keys.
///
/// This function fetches JSON objects from Redis using RedisJSON based on the provided keys.
///
/// # Arguments
///
/// * `prefix` - A string slice representing the prefix for the Redis keys.
/// * `keys` - A slice of strings representing the keys under which the values are stored.
/// * `path` - An optional string slice representing the JSON path from which the value should be retrieved. Defaults to the root path "$".
///
/// # Returns
///
/// Returns a vector of optional values corresponding to the provided keys.
///
/// # Errors
///
/// Returns an error if the operation fails.
pub async fn get_multiple<T: DeserializeOwned + Send + Sync>(
    prefix: &str,
    keys: &[impl AsRef<str>],
    path: Option<&str>,
) -> Result<Vec<Option<T>>, Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;
    let json_path = path.unwrap_or("$");

    // Generate full keys with prefix
    let full_keys: Vec<String> = keys
        .iter()
        .map(|key| format!("{}:{}", prefix, key.as_ref()))
        .collect();

    // Fetch values as Option<String> to handle missing keys
    let indexed_values: Vec<Option<String>> = redis_conn.json_get(&full_keys, json_path).await?;

    // Check if indexed_values is empty. That's an edge case 1 element and it was not found, redis does not return None.
    let results: Vec<Option<T>> = if indexed_values.is_empty() {
        (0..keys.len()).map(|_| None).collect()
    } else {
        deserialize_values(indexed_values)
    };

    Ok(results)
}

// Helper function to deserialize JSON strings to Vec<Option<T>>
fn deserialize_values<T: DeserializeOwned>(values: Vec<Option<String>>) -> Vec<Option<T>> {
    values
        .into_iter()
        .map(|opt| {
            opt.and_then(|value_str| {
                serde_json::from_str::<Vec<T>>(&value_str)
                    .ok()
                    .and_then(|vec| vec.into_iter().next())
            })
        })
        .collect()
}

/// Retrieves a boolean value from Redis.
///
/// # Arguments
///
/// * `prefix` - A string slice that represents the prefix for the Redis key.
/// * `key` - A string slice that represents the key under which the value is stored.
///
/// # Returns
///
/// Returns an `Option` containing the retrieved boolean value if it exists, or `None` if it does not.
///
/// # Errors
///
/// Returns an error if the operation fails.
pub async fn _get_bool(
    prefix: &str,
    key: &str,
) -> Result<Option<bool>, Box<dyn Error + Send + Sync>> {
    let mut redis_conn = get_redis_conn().await?;
    let index_key = format!("{}:{}", prefix, key);

    if let Ok(indexed_value) = redis_conn.get::<_, i32>(&index_key).await {
        debug!(
            "Restored boolean key: {} with value: {}",
            index_key, indexed_value
        );
        let value = match indexed_value {
            1 => true,
            0 => false,
            _ => return Ok(None), // Invalid value in Redis
        };
        return Ok(Some(value));
    }

    Ok(None)
}
```
./src/db/connectors/neo4j.rs
```
use neo4rs::Graph;
use once_cell::sync::OnceCell;
use std::fmt;
use std::sync::Arc;
use tokio::sync::Mutex;

pub struct Neo4jConnector {
    pub graph: OnceCell<Arc<Mutex<Graph>>>,
}

impl Default for Neo4jConnector {
    fn default() -> Self {
        Self::new()
    }
}

impl Neo4jConnector {
    pub fn new() -> Self {
        Self {
            graph: OnceCell::new(),
        }
    }

    pub async fn connect(
        &self,
        uri: &str,
        user: &str,
        password: &str,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let graph = Graph::new(uri, user, password).await?;
        self.graph
            .set(Arc::new(Mutex::new(graph)))
            .map_err(|_| "Failed to set graph instance")?;
        Ok(())
    }

    pub async fn new_connection(
        uri: &str,
        user: &str,
        password: &str,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let neo4j_connector = Neo4jConnector::new();
        neo4j_connector.connect(uri, user, password).await?;
        Ok(neo4j_connector)
    }
}

impl fmt::Debug for Neo4jConnector {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Neo4jConnector")
            .field("graph", &"Graph instance")
            .finish()
    }
}

/// Helper to retrieve a Neo4j graph connection.
pub fn get_neo4j_graph() -> Result<Arc<Mutex<Graph>>, &'static str> {
    let neo4j_connector = NEO4J_CONNECTOR
        .get()
        .ok_or("Neo4jConnector not initialized")?;
    let graph = neo4j_connector
        .graph
        .get()
        .ok_or("Not connected to Neo4j")?;
    Ok(graph.clone())
}

pub static NEO4J_CONNECTOR: OnceCell<Neo4jConnector> = OnceCell::new();
```
./src/db/connectors/mod.rs
```
pub mod neo4j;
pub mod redis;
```
./src/db/connectors/redis.rs
```
use once_cell::sync::OnceCell;
use redis::aio::MultiplexedConnection;
use redis::Client;
use std::fmt;

pub struct RedisConnector {
    client: OnceCell<Client>,
}

impl Default for RedisConnector {
    fn default() -> Self {
        Self::new()
    }
}

impl RedisConnector {
    pub fn new() -> Self {
        Self {
            client: OnceCell::new(),
        }
    }

    pub async fn connect(&self, uri: &str) -> Result<(), Box<dyn std::error::Error>> {
        let client = Client::open(uri)?;
        self.client
            .set(client)
            .map_err(|_| "Failed to set Redis client instance")?;
        Ok(())
    }

    pub async fn new_connection(uri: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let redis_connector = RedisConnector::new();
        redis_connector.connect(uri).await?;
        Ok(redis_connector)
    }

    pub fn client(&self) -> &Client {
        self.client.get().expect("Not connected to Redis")
    }
}

impl fmt::Debug for RedisConnector {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("RedisConnector")
            .field("client", &"Redis client instance")
            .finish()
    }
}

/// Retrieves a Redis connection.
pub async fn get_redis_conn(
) -> Result<MultiplexedConnection, Box<dyn std::error::Error + Send + Sync>> {
    let redis_client = REDIS_CONNECTOR
        .get()
        .ok_or("RedisConnector not initialized")?
        .client();
    let redis_conn = redis_client.get_multiplexed_async_connection().await?;
    Ok(redis_conn)
}

pub static REDIS_CONNECTOR: OnceCell<RedisConnector> = OnceCell::new();
```
./src/db/mod.rs
```
pub mod connectors;
pub mod graph;
pub mod kv;
```
./src/db/graph/mod.rs
```
pub mod queries;
```
./src/db/graph/queries.rs
```
use crate::db::connectors::neo4j::get_neo4j_graph;
use neo4rs::{query, Query};

// Set graph constraints if they do not already exist
pub async fn setup_graph() -> Result<(), Box<dyn std::error::Error>> {
    let constraints = [
        "CREATE CONSTRAINT uniqueUserId IF NOT EXISTS FOR (u:User) REQUIRE u.id IS UNIQUE",
        "CREATE CONSTRAINT uniquePostId IF NOT EXISTS FOR (p:Post) REQUIRE p.id IS UNIQUE",
    ];

    let indexes = [
        "CREATE INDEX userIdIndex IF NOT EXISTS FOR (u:User) ON (u.id)",
        "CREATE INDEX postIdIndex IF NOT EXISTS FOR (p:Post) ON (p.id)",
    ];

    let queries = constraints.iter().chain(indexes.iter());

    let graph = get_neo4j_graph()?;
    let graph = graph.lock().await;
    for q in queries {
        graph.run(query(q)).await?;
    }

    Ok(())
}

// Create nodes with Merge (avoid key duplication). Examples:
// MERGE (u:User {id: "4snwyct86m383rsduhw5xgcxpw7c63j3pq8x4ycqikxgik8y64ro"}) SET u.name = "Aldert", u.status = "working", u.links = ...
// MERGE (p:Post {id: "0RDV7ABDZDW0"}) SET p.content = "Julian Assange is free", p.uri = "pubky:pxnu33x7jtpx9ar1ytsi4yxbp6a5o36gwhffs8zoxmbuptici1jy/pubky.app/posts/0RDV7ABDZDW0", p.createdAt = 1719308315917;

// Retrieve post node by post id and author id
pub fn get_post_by_id(author_id: &str, post_id: &str) -> Query {
    query("MATCH (u:User {id: $author_id})-[:AUTHORED]->(p:Post {id: $post_id}) RETURN p")
        .param("author_id", author_id)
        .param("post_id", post_id)
}

pub fn post_counts(author_id: &str, post_id: &str) -> Query {
    query(
        "MATCH (u:User {id: $author_id})-[:AUTHORED]->(p:Post {id: $post_id})
         OPTIONAL MATCH (p)<-[tag:TAGGED]-()
         OPTIONAL MATCH (p)<-[reply:REPLIED]-()
         OPTIONAL MATCH (p)<-[repost:REPOSTED]-()
         RETURN COUNT(p) > 0 AS post_exists,
                COUNT(DISTINCT tag) AS tags_count,
                COUNT(DISTINCT reply) AS replies_count,
                COUNT(DISTINCT repost) AS reposts_count",
    )
    .param("author_id", author_id)
    .param("post_id", post_id)
}

pub fn post_bookmark(author_id: &str, post_id: &str, viewer_id: &str) -> Query {
    query(
        "MATCH (u:User {id: $author_id})-[:AUTHORED]->(p:Post {id: $post_id})
         OPTIONAL MATCH (viewer:User {id: $viewer_id})-[b:BOOKMARKED]->(p)
         RETURN b",
    )
    .param("author_id", author_id)
    .param("post_id", post_id)
    .param("viewer_id", viewer_id)
}

pub fn user_bookmarks(user_id: &str) -> Query {
    query(
        "MATCH (u:User {id: $user_id})-[b:BOOKMARKED]->(p:Post)<-[:AUTHORED]-(author:User)
         RETURN b, p.id AS post_id, author.id AS author_id",
    )
    .param("user_id", user_id)
}

pub fn post_relationships(author_id: &str, post_id: &str) -> Query {
    query(
        "MATCH (u:User {id: $author_id})-[:AUTHORED]->(p:Post {id: $post_id})
        OPTIONAL MATCH (p)-[:REPLIED]->(replied_post:Post)<-[:AUTHORED]-(replied_author:User)
        OPTIONAL MATCH (p)-[:REPOSTED]->(reposted_post:Post)<-[:AUTHORED]-(reposted_author:User)
        OPTIONAL MATCH (p)-[:MENTIONED]->(mentioned_user:User)
        RETURN 
          replied_post.id AS replied_post_id, 
          replied_author.id AS replied_author_id,
          reposted_post.id AS reposted_post_id, 
          reposted_author.id AS reposted_author_id,
          COLLECT(mentioned_user.id) AS mentioned_user_ids",
    )
    .param("author_id", author_id)
    .param("post_id", post_id)
}

// Retrieve many users by id
// We return also id if not we will not get not found users
pub fn get_users_details_by_ids(user_ids: &[&str]) -> Query {
    query(
        "
        UNWIND $ids AS id
        OPTIONAL MATCH (user:User {id: id})
        RETURN 
            id,
            CASE 
                WHEN user IS NOT NULL 
                    THEN user { .id, .bio, .status, .name, .indexed_at, .links }
                    ELSE null
                END AS record
        ",
    )
    .param("ids", user_ids)
}

/// Retrieve all the tags of the post
pub fn post_tags(user_id: &str, post_id: &str) -> neo4rs::Query {
    query(
        "
        MATCH (u:User {id: $user_id})-[:AUTHORED]->(p:Post {id: $post_id})
        CALL {
            WITH p
            MATCH (tagger:User)-[tag:TAGGED]->(p)
            WITH tag.label AS name,
                collect({
                    tag_id: tag.id,
                    indexed_at: tag.indexed_at,
                    tagger_id: tagger.id
                }) AS from
            RETURN collect({
                label: name,
                tagged: from
            }) AS post_tags
        }
        RETURN 
            u IS NOT NULL AS post_exists,
            post_tags
    ",
    )
    .param("user_id", user_id)
    .param("post_id", post_id)
}

pub fn user_tags(user_id: &str) -> neo4rs::Query {
    query(
        "
        MATCH (u:User {id: $user_id})
        CALL {
            WITH u
            MATCH (p:User)-[r:TAGGED]->(u)
            WITH r.label AS name,
                collect({
                    tag_id: r.id,
                    indexed_at: r.indexed_at,
                    tagger_id: p.id
                }) AS from
            RETURN collect({
                label: name,
                tagged: from
            }) AS user_tags
        }
        RETURN 
            u IS NOT NULL AS user_exists,
            user_tags
    ",
    )
    .param("user_id", user_id)
}

pub fn user_counts(user_id: &str) -> neo4rs::Query {
    query(
        "MATCH (u:User {id: $id})
           OPTIONAL MATCH (u)-[:FOLLOWS]->(following:User)
           OPTIONAL MATCH (follower:User)-[:FOLLOWS]->(u)
           OPTIONAL MATCH (u)-[:FOLLOWS]->(friend:User)-[:FOLLOWS]->(u)
           OPTIONAL MATCH (u)-[:AUTHORED]->(post:Post)
           OPTIONAL MATCH (u)-[tag:TAGGED]->(:Post)
           RETURN COUNT(u) > 0 AS user_exists,
                  COUNT(DISTINCT following) AS following_count,
                  COUNT(DISTINCT follower) AS followers_count,
                  COUNT(DISTINCT friend) AS friends_count,
                  COUNT(DISTINCT post) AS posts_count,
                  COUNT(DISTINCT tag) AS tags_count",
    )
    .param("id", user_id)
}

pub fn get_user_followers(user_id: &str, skip: Option<usize>, limit: Option<usize>) -> Query {
    let mut query_string = String::from(
        "MATCH (u:User {id: $user_id}) 
         OPTIONAL MATCH (u)<-[:FOLLOWS]-(follower:User)
         RETURN COUNT(u) > 0 AS user_exists, 
                COLLECT(follower.id) AS follower_ids",
    );
    if let Some(skip_value) = skip {
        query_string.push_str(&format!(" SKIP {}", skip_value));
    }
    if let Some(limit_value) = limit {
        query_string.push_str(&format!(" LIMIT {}", limit_value));
    }
    query(&query_string).param("user_id", user_id)
}

pub fn get_user_following(user_id: &str, skip: Option<usize>, limit: Option<usize>) -> Query {
    let mut query_string = String::from(
        "MATCH (u:User {id: $user_id}) 
         OPTIONAL MATCH (u)-[:FOLLOWS]->(following:User)
         RETURN COUNT(u) > 0 AS user_exists, 
                COLLECT(following.id) AS following_ids",
    );
    if let Some(skip_value) = skip {
        query_string.push_str(&format!(" SKIP {}", skip_value));
    }
    if let Some(limit_value) = limit {
        query_string.push_str(&format!(" LIMIT {}", limit_value));
    }
    query(&query_string).param("user_id", user_id)
}
```
./src/setup.rs
```
use crate::config::Config;
use crate::db::connectors::{
    neo4j::{Neo4jConnector, NEO4J_CONNECTOR},
    redis::{RedisConnector, REDIS_CONNECTOR},
};
use crate::queries::setup_graph;
use log::{error, info};

async fn setup_redis(config: &Config) {
    let redis_connector = RedisConnector::new_connection(&config.redis_uri())
        .await
        .expect("Failed to connect to Redis");

    match REDIS_CONNECTOR.set(redis_connector) {
        Err(e) => error!("RedisConnector was already set: {:?}", e),
        Ok(()) => info!("RedisConnector successfully set"),
    }
}

async fn setup_neo4j(config: &Config) {
    let neo4j_connector = Neo4jConnector::new_connection(
        &config.neo4j_uri(),
        &config.neo4j_username,
        &config.neo4j_password,
    )
    .await
    .expect("Failed to connect to Neo4j");

    match NEO4J_CONNECTOR.set(neo4j_connector) {
        Err(e) => error!("Neo4jConnector was already set: {:?}", e),
        Ok(()) => info!("Neo4jConnector successfully set"),
    }

    // Set Neo4J graph data constraints
    setup_graph().await.unwrap_or_default();
}

pub async fn setup(config: &Config) {
    env_logger::init();

    // Initialize Redis and Neo4j
    setup_redis(config).await;
    setup_neo4j(config).await;
}
```
./src/reindex.rs
```
use crate::db::kv::flush::clear_redis;
use crate::models::post::Bookmark;
use crate::models::user::{Followers, Following, UserDetails, UserFollows};
use crate::models::traits::Collection;
use crate::{
    db::connectors::neo4j::get_neo4j_graph,
    models::post::{PostCounts, PostDetails, PostRelationships},
    models::user::UserCounts,
};
use log::info;
use neo4rs::query;
use tokio::task::JoinSet;

pub async fn reindex() {
    // Clear Redis database
    if let Err(e) = clear_redis().await {
        log::error!("Failed to clear Redis: {:?}", e);
        return;
    }

    let mut user_tasks = JoinSet::new();
    let mut post_tasks = JoinSet::new();

    let user_ids: Vec<String> = get_all_user_ids().await.expect("Failed to get user IDs");
    let user_ids_refs: Vec<&str> = user_ids.iter().map(|id| id.as_str()).collect();

    UserDetails::from_graph(&user_ids_refs)
        .await
        .expect("Failed indexing User Details");
    //TODO use collections

    for user_id in user_ids {
        user_tasks.spawn(async move {
            if let Err(e) = reindex_user(&user_id).await {
                log::error!("Failed to reindex user {}: {:?}", user_id, e);
            }
        });
    }

    let post_ids = get_all_post_ids().await.expect("Failed to get post IDs");
    for (author_id, post_id) in post_ids {
        post_tasks.spawn(async move {
            if let Err(e) = reindex_post(&author_id, &post_id).await {
                log::error!("Failed to reindex post {}: {:?}", post_id, e);
            }
        });
    }

    while let Some(res) = user_tasks.join_next().await {
        if let Err(e) = res {
            log::error!("User reindexing task failed: {:?}", e);
        }
    }

    while let Some(res) = post_tasks.join_next().await {
        if let Err(e) = res {
            log::error!("Post reindexing task failed: {:?}", e);
        }
    }

    info!("Reindexing completed successfully.");
}

async fn reindex_user(user_id: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    tokio::try_join!(
        Bookmark::index_all_from_graph(user_id),
        UserCounts::get_from_graph(user_id),
        Followers::get_from_graph(user_id, Some(0), Some(100)),
        Following::get_from_graph(user_id, Some(0), Some(100)),
    )?;

    Ok(())
}

async fn reindex_post(
    author_id: &str,
    post_id: &str,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    tokio::try_join!(
        PostDetails::get_from_graph(author_id, post_id),
        PostCounts::get_from_graph(author_id, post_id),
        PostRelationships::get_from_graph(author_id, post_id)
    )?;

    Ok(())
}

async fn get_all_user_ids() -> Result<Vec<String>, Box<dyn std::error::Error + Send + Sync>> {
    let graph = get_neo4j_graph()?;
    let query = query("MATCH (u:User) RETURN u.id AS id");

    let graph = graph.lock().await;
    let mut result = graph.execute(query).await?;

    let mut user_ids = Vec::new();
    while let Some(row) = result.next().await? {
        if let Some(id) = row.get("id")? {
            user_ids.push(id);
        }
    }

    Ok(user_ids)
}

async fn get_all_post_ids(
) -> Result<Vec<(String, String)>, Box<dyn std::error::Error + Send + Sync>> {
    let graph = get_neo4j_graph()?;
    let query =
        query("MATCH (u:User)-[:AUTHORED]->(p:Post) RETURN u.id AS author_id, p.id AS post_id");

    let graph = graph.lock().await;
    let mut result = graph.execute(query).await?;

    let mut post_ids = Vec::new();
    while let Some(row) = result.next().await? {
        if let (Some(author_id), Some(post_id)) = (row.get("author_id")?, row.get("post_id")?) {
            post_ids.push((author_id, post_id));
        }
    }

    Ok(post_ids)
}
```
./src/lib.rs
```
mod config;
mod db;
mod error;
pub mod models;
mod reindex;
pub mod routes;
mod setup;

pub use config::Config;
pub use db::graph::queries;
pub use db::kv::traits::RedisOps;
pub use error::{Error, Result};
pub use reindex::reindex;
pub use setup::setup;
```
./src/config.rs
```
use dotenv::dotenv;
use std::env;

#[derive(Debug, Clone)]
pub struct Config {
    neo4j_host: String,
    neo4j_port: String,
    pub neo4j_username: String,
    pub neo4j_password: String,
    redis_host: String,
    redis_port: String,
    pub static_path: String,
    server_host: String,
    server_port: String,
    pub reindex: bool,
}

impl Config {
    pub fn from_env() -> Self {
        dotenv().ok();

        Self {
            neo4j_host: env::var("NEO4J_HOST").unwrap_or_else(|_| "localhost".to_string()),
            neo4j_port: env::var("NEO4J_PORT").unwrap_or_else(|_| "7687".to_string()),
            neo4j_username: env::var("NEO4J_DB_USERNAME").expect("NEO4J_DB_USERNAME not set"),
            neo4j_password: env::var("NEO4J_PASSWORD").expect("NEO4J_PASSWORD not set"),
            redis_host: env::var("REDIS_HOST").unwrap_or_else(|_| "localhost".to_string()),
            redis_port: env::var("REDIS_PORT").unwrap_or_else(|_| "6379".to_string()),
            static_path: env::var("STATIC_PATH").unwrap_or_else(|_| "./".to_string()),
            server_host: env::var("SERVER_HOST").unwrap_or_else(|_| "127.0.0.1".to_string()),
            server_port: env::var("SERVER_PORT").unwrap_or_else(|_| "8080".to_string()),
            reindex: env::var("REINDEX")
                .unwrap_or_else(|_| "false".to_string())
                .parse()
                .unwrap_or(false),
        }
    }

    pub fn neo4j_uri(&self) -> String {
        format!("bolt://{}:{}", self.neo4j_host, self.neo4j_port)
    }

    pub fn redis_uri(&self) -> String {
        format!("redis://{}:{}", self.redis_host, self.redis_port)
    }

    pub fn server_binding(&self) -> String {
        format!("{}:{}", self.server_host, self.server_port)
    }
}
```
./src/service.rs
```
use log::info;
use pubky_nexus::{reindex, routes, setup, Config};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() {
    let config = Config::from_env();
    setup(&config).await;

    // Reindex if REINDEX is set to true
    match config.reindex {
        true => {
            info!("REINDEX=true detected. Starting reindexing process.");
            reindex().await;
        }
        false => (),
    }

    // App router
    let app = routes::routes();

    // Start server
    let listener = TcpListener::bind(&config.server_binding()).await.unwrap();
    info!("Listening on {:?}\n", listener.local_addr().unwrap());
    axum::serve(listener, app.into_make_service())
        .await
        .unwrap();
}
```
./src/error.rs
```
use axum::http::StatusCode;
use axum::response::{IntoResponse, Response};
use log::{debug, error};
use thiserror::Error;

pub type Result<T> = core::result::Result<T, Error>;

#[derive(Error, Debug)]
pub enum Error {
    #[error("User not found: {user_id}")]
    UserNotFound { user_id: String },
    #[error("Post not found: {author_id} {post_id}")]
    PostNotFound { author_id: String, post_id: String },
    #[error("Internal server error: {source}")]
    InternalServerError { source: Box<dyn std::error::Error> },
    #[error("Bookmarks not found: {user_id}")]
    BookmarksNotFound { user_id: String },
    // Add other custom errors here
}

impl IntoResponse for Error {
    fn into_response(self) -> Response {
        // HTTP Status codes
        let status_code = match self {
            Error::UserNotFound { .. } => StatusCode::NOT_FOUND,
            Error::PostNotFound { .. } => StatusCode::NOT_FOUND,
            Error::BookmarksNotFound { .. } => StatusCode::NOT_FOUND,
            Error::InternalServerError { .. } => StatusCode::INTERNAL_SERVER_ERROR,
            // Map other errors to appropriate status codes
        };

        // Logging
        match &self {
            Error::UserNotFound { user_id } => debug!("User not found: {}", user_id),
            Error::PostNotFound { author_id, post_id } => {
                debug!("Post not found: {} {}", author_id, post_id)
            }
            Error::BookmarksNotFound { user_id } => {
                debug!("Bookmarks not found: {}", user_id)
            }
            Error::InternalServerError { source } => error!("Internal server error: {:?}", source),
        };

        let body = serde_json::json!({
            "error": self.to_string()
        });

        (status_code, axum::Json(body)).into_response()
    }
}
```
./src/models/mod.rs
```
pub mod info;
pub mod post;
pub mod tag;
pub mod user;
pub mod traits;```
./src/models/traits.rs
```
use axum::async_trait;
use neo4rs::Query;

use crate::RedisOps;
use crate::db::connectors::neo4j::get_neo4j_graph;
use std::fmt::Debug;

#[async_trait]
pub trait Collection
where
    Self: RedisOps + Clone + Debug + Default,
{
    /// Retrieves records by their IDs, first attempting to fetch them from a cache (e.g., Redis),
    /// and then querying a graph database (e.g., Neo4j) if necessary.
    ///
    /// # Arguments
    ///
    /// * `id_list` - A slice of string slices representing the IDs to query.
    /// * `collection_type` - An enum value of `CollectionType` specifying the type of collection (e.g., User, Post, Tag).
    ///
    /// # Returns
    ///
    /// This function returns a `Result` containing a vector of `Option<Self>`. Each `Option` corresponds to
    /// a queried ID, containing `Some(record)` if the record was found in either the cache or the graph database,
    /// or `None` if it was not found in either.
    async fn get_by_ids(
        id_list: &[&str]
    ) -> Result<Vec<Option<Self>>, Box<dyn std::error::Error + Send + Sync>> {
        let key_parts_list: Vec<&[&str]> = id_list.iter().map(std::slice::from_ref).collect();
        let mut collection = Self::try_from_index_multiple_json(&key_parts_list).await?;

        let mut missing: Vec<(usize, &str)> = Vec::new();

        for (i, details) in collection.iter().enumerate() {
            if details.is_none() {
                missing.push((i, id_list[i]));
            }
        }

        if !missing.is_empty() {
            let missing_ids: Vec<&str> = missing.iter().map(|&(_, id)| id).collect();
            let fetched_details = Self::from_graph(&missing_ids).await?;

            for (i, (original_index, _)) in missing.iter().enumerate() {
                collection[*original_index].clone_from(&fetched_details[i]);
            }
        }

        Ok(collection)
    }

    /// Queries a Neo4j graph database to retrieve records based on the provided IDs and collection type.
    ///
    /// # Arguments
    ///
    /// * `missing_ids` - A slice of string slices representing the IDs that were not found in the cache.
    /// * `collection_type` - An enum value of `CollectionType` specifying the type of collection to query (e.g., User, Post, Tag).
    ///
    /// # Returns
    ///
    /// This function returns a `Result` containing a vector of `Option<Self>`. Each `Option` corresponds to
    /// a queried ID, containing `Some(record)` if the record was found in the graph database, or `None` if it was not found.
    async fn from_graph(
        missing_ids: &[&str]
    ) -> Result<Vec<Option<Self>>, Box<dyn std::error::Error + Send + Sync>> {
        let graph = get_neo4j_graph()?;
        let query = Self::graph_query(missing_ids);

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;
        let mut missing_records = Vec::with_capacity(missing_ids.len());

        while let Some(row) = result.next().await? {
            let record: Option<Self> = row.get("record").unwrap_or_default();
            missing_records.push(record);
        }

        if !missing_records.is_empty() {
            let mut existing_records = Vec::new();
            let mut existing_record_ids = Vec::new();

            for (detail, id) in missing_records.iter().zip(missing_ids.iter()) {
                if let Some(record) = detail {
                    existing_records.push(Some(record.clone()));
                    existing_record_ids.push(*id);
                }
            }

            Self::to_index(&existing_record_ids, existing_records).await?;
        }

        Ok(missing_records)
    }

    /// Indexes collection of records in Redis for faster access in future queries.
    ///
    /// # Arguments
    ///
    /// * `user_ids` - A slice of string slices representing the IDs of the records to index.
    /// * `existing_records` - A vector of `Option<Self>` containing the records to be indexed.
    ///   Each `Option` corresponds to an ID in `user_ids`.
    ///
    /// # Returns
    ///
    /// This function returns a `Result` indicating success or failure. A successful result indicates that the
    /// records were successfully indexed in the cache.
    async fn to_index(
        user_ids: &[&str],
        existing_records: Vec<Option<Self>>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let key_parts_list: Vec<Vec<&str>> = user_ids.iter().map(|id| vec![*id]).collect();
        let keys_refs: Vec<&[&str]> = key_parts_list.iter().map(|key| &key[..]).collect();

        Self::put_multiple_json_indexes(&keys_refs, existing_records).await
    }

    fn graph_query(id_list: &[&str]) -> Query;
}
```
./src/models/post/mod.rs
```
mod bookmark;
mod counts;
mod details;
mod relationships;
mod stream;
mod view;

pub use bookmark::Bookmark;
pub use counts::PostCounts;
pub use details::PostDetails;
pub use relationships::PostRelationships;
pub use stream::{PostStream, PostStreamReach, PostStreamSorting};
pub use view::PostView;
```
./src/models/post/bookmark.rs
```
use crate::db::connectors::neo4j::get_neo4j_graph;
use crate::{queries, RedisOps};
use chrono::Utc;
use neo4rs::Relation;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use super::PostStream;

#[derive(Serialize, Deserialize, ToSchema)]
pub struct Bookmark {
    id: String,
    pub indexed_at: i64,
}

impl RedisOps for Bookmark {}

impl Default for Bookmark {
    fn default() -> Self {
        Self::new()
    }
}

impl Bookmark {
    pub fn new() -> Self {
        Self {
            id: String::new(),
            indexed_at: Utc::now().timestamp(),
        }
    }

    /// Retrieves counts by user ID, first trying to get from Redis, then from Neo4j if not found.
    pub async fn get_by_id(
        author_id: &str,
        post_id: &str,
        viewer_id: Option<&str>,
    ) -> Result<Option<Bookmark>, Box<dyn std::error::Error + Send + Sync>> {
        // Return None early if no viewer_id supplied
        let viewer_id = match viewer_id {
            Some(viewer_id) => viewer_id,
            None => return Ok(None),
        };
        match Self::try_from_index_json(&[author_id, post_id, viewer_id]).await? {
            Some(counts) => Ok(Some(counts)),
            None => Self::get_from_graph(author_id, post_id, viewer_id).await,
        }
    }

    /// Retrieves a bookmark from Neo4j.
    pub async fn get_from_graph(
        author_id: &str,
        post_id: &str,
        viewer_id: &str,
    ) -> Result<Option<Bookmark>, Box<dyn std::error::Error + Send + Sync>> {
        let graph = get_neo4j_graph()?;
        let query = queries::post_bookmark(author_id, post_id, viewer_id);

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        if let Some(row) = result.next().await? {
            // TODO, research why sometimes there is a result that is not a Relation here ?
            let relation: Relation = match row.get("b") {
                Ok(value) => value,
                Err(_) => return Ok(None),
            };
            let bookmark = Self {
                id: relation.get("id").unwrap_or_default(),
                indexed_at: relation.get("indexed_at").unwrap_or_default(),
            };
            bookmark
                .put_index_json(&[author_id, post_id, viewer_id])
                .await?;
            PostStream::add_to_bookmarks_sorted_set(&bookmark, viewer_id, post_id, author_id)
                .await?;
            Ok(Some(bookmark))
        } else {
            Ok(None)
        }
    }

    /// Retrieves all post_keys a user bookmarked from Neo4j
    pub async fn index_all_from_graph(
        user_id: &str,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let graph = get_neo4j_graph()?;
        let query = queries::user_bookmarks(user_id);

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        let mut bookmarked_post_keys = Vec::new();

        while let Some(row) = result.next().await? {
            if let Some(relation) = row.get::<Option<Relation>>("b")? {
                let bookmark = Bookmark {
                    id: relation.get("id").unwrap_or_default(),
                    indexed_at: relation.get("indexed_at").unwrap_or_default(),
                };
                let author_id = row.get("author_id")?;
                let post_id = row.get("post_id")?;
                PostStream::add_to_bookmarks_sorted_set(&bookmark, user_id, post_id, author_id)
                    .await?;
                bookmarked_post_keys.push(format!("{}:{}", author_id, post_id));
            }
        }
        Ok(())
    }
}
```
./src/models/post/details.rs
```
use crate::db::connectors::neo4j::get_neo4j_graph;
use crate::{queries, RedisOps};
use chrono::Utc;
use neo4rs::Node;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use super::PostStream;

/// Represents post data with content, bio, image, links, and status.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct PostDetails {
    content: String,
    pub id: String, // TODO: create Crockfordbase32 validator
    pub indexed_at: i64,
    pub author: String,
    uri: String,
}

impl RedisOps for PostDetails {}

impl Default for PostDetails {
    fn default() -> Self {
        Self::new()
    }
}

impl PostDetails {
    pub fn new() -> Self {
        Self {
            content: String::new(),
            id: String::new(),
            indexed_at: Utc::now().timestamp(),
            author: String::new(),
            uri: String::new(),
        }
    }

    /// Retrieves post details by author ID and post ID, first trying to get from Redis, then from Neo4j if not found.
    pub async fn get_by_id(
        author_id: &str,
        post_id: &str,
    ) -> Result<Option<PostDetails>, Box<dyn std::error::Error + Send + Sync>> {
        match Self::try_from_index_json(&[author_id, post_id]).await? {
            Some(details) => Ok(Some(details)),
            None => Self::get_from_graph(author_id, post_id).await,
        }
    }

    async fn from_node(node: &Node, author_id: &str) -> Self {
        let id = node.get("id").unwrap_or_default();
        Self {
            uri: format!("pubky://{author_id}/pub/pubky.app/posts/{id}"),
            content: node.get("content").unwrap_or_default(),
            id,
            indexed_at: node.get("indexed_at").unwrap_or_default(),
            author: String::from(author_id),
        }
    }

    /// Retrieves the post fields from Neo4j.
    pub async fn get_from_graph(
        author_id: &str,
        post_id: &str,
    ) -> Result<Option<PostDetails>, Box<dyn std::error::Error + Send + Sync>> {
        let graph = get_neo4j_graph()?;
        let query = queries::get_post_by_id(author_id, post_id);

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        match result.next().await? {
            Some(row) => {
                let node: Node = row.get("p")?;
                let post = Self::from_node(&node, author_id).await;
                post.put_index_json(&[author_id, post_id]).await?;
                PostStream::add_to_timeline_sorted_set(&post).await?;
                PostStream::add_to_per_user_sorted_set(&post).await?;
                Ok(Some(post))
            }
            None => Ok(None),
        }
    }
}
```
./src/models/post/relationships.rs
```
use crate::db::connectors::neo4j::get_neo4j_graph;
use crate::{queries, RedisOps};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

#[derive(Serialize, Deserialize, ToSchema)]
pub struct PostRelationships {
    // URI of the replied post
    replied: Option<String>,
    // URI of the reposted post
    reposted: Option<String>,
    // List of user IDs
    mentioned: Option<Vec<String>>,
}

impl RedisOps for PostRelationships {}

impl Default for PostRelationships {
    fn default() -> Self {
        Self::new()
    }
}

impl PostRelationships {
    pub fn new() -> Self {
        Self {
            replied: None,
            reposted: None,
            mentioned: None,
        }
    }

    /// Retrieves post relationships by user ID, first trying to get from Redis, then from Neo4j if not found.
    pub async fn get_by_id(
        author_id: &str,
        post_id: &str,
    ) -> Result<Option<PostRelationships>, Box<dyn std::error::Error + Send + Sync>> {
        match Self::try_from_index_json(&[author_id, post_id]).await? {
            Some(counts) => Ok(Some(counts)),
            None => Self::get_from_graph(author_id, post_id).await,
        }
    }

    /// Retrieves the counts from Neo4j.
    pub async fn get_from_graph(
        author_id: &str,
        post_id: &str,
    ) -> Result<Option<PostRelationships>, Box<dyn std::error::Error + Send + Sync>> {
        let graph = get_neo4j_graph()?;
        let query = queries::post_relationships(author_id, post_id);

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        if let Some(row) = result.next().await? {
            let replied_post_id: Option<String> = row.get("replied_post_id")?;
            let replied_author_id: Option<String> = row.get("replied_author_id")?;
            let reposted_post_id: Option<String> = row.get("reposted_post_id")?;
            let reposted_author_id: Option<String> = row.get("reposted_author_id")?;
            let mentioned: Option<Vec<String>> = row.get("mentioned_user_ids")?;

            let replied = match (replied_author_id, replied_post_id) {
                (Some(author_id), Some(post_id)) => {
                    Some(format!("pubky:{author_id}/pubky.app/posts/{post_id}"))
                }
                _ => None,
            };
            let reposted = match (reposted_author_id, reposted_post_id) {
                (Some(author_id), Some(post_id)) => {
                    Some(format!("pubky:{author_id}/pubky.app/posts/{post_id}"))
                }
                _ => None,
            };
            let relationships = Self {
                replied,
                reposted,
                mentioned,
            };
            relationships.put_index_json(&[author_id, post_id]).await?;
            Ok(Some(relationships))
        } else {
            Ok(None)
        }
    }
}
```
./src/models/post/counts.rs
```
use crate::db::connectors::neo4j::get_neo4j_graph;
use crate::{queries, RedisOps};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use super::PostStream;

/// Represents total counts of relationships of a user.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct PostCounts {
    pub tags: u32,
    pub replies: u32,
    pub reposts: u32,
}

impl RedisOps for PostCounts {}

impl Default for PostCounts {
    fn default() -> Self {
        Self::new()
    }
}

impl PostCounts {
    pub fn new() -> Self {
        Self {
            tags: 0,
            replies: 0,
            reposts: 0,
        }
    }

    /// Retrieves counts by user ID, first trying to get from Redis, then from Neo4j if not found.
    pub async fn get_by_id(
        author_id: &str,
        post_id: &str,
    ) -> Result<Option<PostCounts>, Box<dyn std::error::Error + Send + Sync>> {
        match Self::try_from_index_json(&[author_id, post_id]).await? {
            Some(counts) => Ok(Some(counts)),
            None => Self::get_from_graph(author_id, post_id).await,
        }
    }

    /// Retrieves the counts from Neo4j.
    pub async fn get_from_graph(
        author_id: &str,
        post_id: &str,
    ) -> Result<Option<PostCounts>, Box<dyn std::error::Error + Send + Sync>> {
        let graph = get_neo4j_graph()?;
        let query = queries::post_counts(author_id, post_id);

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        if let Some(row) = result.next().await? {
            if !row.get("post_exists").unwrap_or(false) {
                return Ok(None);
            }
            let counts = Self {
                tags: row.get("tags_count").unwrap_or_default(),
                replies: row.get("replies_count").unwrap_or_default(),
                reposts: row.get("reposts_count").unwrap_or_default(),
            };
            counts.put_index_json(&[author_id, post_id]).await?;
            PostStream::add_to_engagement_sorted_set(&counts, author_id, post_id).await?;
            Ok(Some(counts))
        } else {
            Ok(None)
        }
    }
}
```
./src/models/post/stream.rs
```
use super::{Bookmark, PostCounts, PostDetails, PostView};
use crate::{
    db::kv::index::sorted_sets::Sorting,
    models::user::{Followers, Following, Friends, UserFollows},
    RedisOps,
};
use serde::{Deserialize, Serialize};
use std::error::Error;
use tokio::task::spawn;
use utoipa::ToSchema;

const POST_TIMELINE_KEY_PARTS: [&str; 3] = ["Posts", "Global", "Timeline"];
const POST_TOTAL_ENGAGEMENT_KEY_PARTS: [&str; 3] = ["Posts", "Global", "TotalEngagement"];
const POST_PER_USER_KEY_PARTS: [&str; 2] = ["Posts", "User"];
const BOOKMARKS_USER_KEY_PARTS: [&str; 2] = ["Bookmarks", "User"];

#[derive(Deserialize, ToSchema)]
pub enum PostStreamSorting {
    Timeline,
    TotalEngagement,
}

#[derive(Deserialize, ToSchema)]
pub enum PostStreamReach {
    Following,
    Followers,
    Friends,
    // TODO unify by_reach, global and per user into a single handler with options!
    // Bookmarks,
    // All,
}

#[derive(Serialize, Deserialize, ToSchema)]
pub struct PostStream(Vec<PostView>);

impl RedisOps for PostStream {}

impl Default for PostStream {
    fn default() -> Self {
        Self::new()
    }
}

impl PostStream {
    pub fn new() -> Self {
        Self(Vec::new())
    }

    pub async fn get_global_posts(
        sorting: PostStreamSorting,
        viewer_id: Option<String>,
        skip: Option<usize>,
        limit: Option<usize>,
    ) -> Result<Option<Self>, Box<dyn Error + Send + Sync>> {
        let posts_sorted_set = match sorting {
            PostStreamSorting::TotalEngagement => {
                Self::try_from_index_sorted_set(
                    &POST_TOTAL_ENGAGEMENT_KEY_PARTS,
                    None,
                    None,
                    skip,
                    limit,
                    Sorting::Descending,
                )
                .await?
            }
            PostStreamSorting::Timeline => {
                Self::try_from_index_sorted_set(
                    &POST_TIMELINE_KEY_PARTS,
                    None,
                    None,
                    skip,
                    limit,
                    Sorting::Descending,
                )
                .await?
            }
        };

        match posts_sorted_set {
            Some(post_keys) => {
                let post_keys: Vec<String> = post_keys.into_iter().map(|(key, _)| key).collect();
                Self::from_listed_post_ids(viewer_id, &post_keys).await
            }
            None => Ok(None),
        }
    }

    pub async fn get_user_posts(
        user_id: &str,
        viewer_id: Option<String>,
        skip: Option<usize>,
        limit: Option<usize>,
    ) -> Result<Option<Self>, Box<dyn Error + Send + Sync>> {
        let key_parts = [&POST_PER_USER_KEY_PARTS[..], &[user_id]].concat();
        let post_ids = Self::try_from_index_sorted_set(
            &key_parts,
            None,
            None,
            skip,
            limit,
            Sorting::Descending,
        )
        .await?;

        if let Some(post_ids) = post_ids {
            let post_keys: Vec<String> = post_ids
                .into_iter()
                .map(|(post_id, _)| format!("{}:{}", user_id, post_id))
                .collect();

            Self::from_listed_post_ids(viewer_id, &post_keys).await
        } else {
            Ok(None)
        }
    }

    pub async fn get_posts_by_reach(
        reach: PostStreamReach,
        viewer_id: Option<String>,
        skip: Option<usize>,
        limit: Option<usize>,
    ) -> Result<Option<Self>, Box<dyn Error + Send + Sync>> {
        let viewer_id = match viewer_id {
            None => return Ok(None),
            Some(v_id) => v_id,
        };

        let user_ids = match reach {
            PostStreamReach::Following => {
                Following::get_by_id(&viewer_id, None, None)
                    .await?
                    .unwrap_or_default()
                    .0
            }
            PostStreamReach::Followers => {
                Followers::get_by_id(&viewer_id, None, None)
                    .await?
                    .unwrap_or_default()
                    .0
            }
            PostStreamReach::Friends => {
                Friends::get_by_id(&viewer_id, None, None)
                    .await?
                    .unwrap_or_default()
                    .0
            }
        };

        if !user_ids.is_empty() {
            let post_keys = Self::get_posts_for_user_ids(
                &user_ids.iter().map(AsRef::as_ref).collect::<Vec<_>>(),
                skip,
                limit,
            )
            .await?;
            Self::from_listed_post_ids(Some(viewer_id), &post_keys).await
        } else {
            Ok(None)
        }
    }

    pub async fn get_bookmarked_posts(
        user_id: &str,
        skip: Option<usize>,
        limit: Option<usize>,
    ) -> Result<Option<Self>, Box<dyn Error + Send + Sync>> {
        let key_parts = [&BOOKMARKS_USER_KEY_PARTS[..], &[user_id]].concat();
        let post_keys = Self::try_from_index_sorted_set(
            &key_parts,
            None,
            None,
            skip,
            limit,
            Sorting::Descending,
        )
        .await?;

        if let Some(post_keys) = post_keys {
            let post_keys: Vec<String> = post_keys.into_iter().map(|(key, _)| key).collect();
            Self::from_listed_post_ids(Some(user_id.to_string()), &post_keys).await
        } else {
            Ok(None)
        }
    }

    // Streams for followers / followings / friends are expensive.
    // We are truncating to the first 200 user_ids. We could also random draw 200.
    // TODO rethink
    async fn get_posts_for_user_ids(
        user_ids: &[&str],
        skip: Option<usize>,
        limit: Option<usize>,
    ) -> Result<Vec<String>, Box<dyn Error + Send + Sync>> {
        let mut post_keys = Vec::new();

        // Limit the number of user IDs to process to the first 200
        let max_user_ids = 200;
        let truncated_user_ids: Vec<&str> = user_ids.iter().take(max_user_ids).cloned().collect();

        // Retrieve posts for each user and collect them
        for user_id in &truncated_user_ids {
            let key_parts = [&POST_PER_USER_KEY_PARTS[..], &[user_id]].concat();
            if let Some(post_ids) = Self::try_from_index_sorted_set(
                &key_parts,
                None,
                None,
                None, // We do not apply skip and limit here, as we need the full sorted set
                None,
                Sorting::Descending,
            )
            .await?
            {
                let user_post_keys: Vec<(f64, String)> = post_ids
                    .into_iter()
                    .map(|(post_id, score)| (score, format!("{}:{}", user_id, post_id)))
                    .collect();
                post_keys.extend(user_post_keys);
            }
        }

        // Sort all the collected posts globally by their score (descending)
        post_keys.sort_by(|a, b| b.0.partial_cmp(&a.0).unwrap_or(std::cmp::Ordering::Equal));

        // Apply global skip and limit after sorting
        let start_index = skip.unwrap_or(0).max(0);
        let end_index = if let Some(limit) = limit {
            (start_index + limit).min(post_keys.len())
        } else {
            post_keys.len()
        };

        let selected_post_keys = post_keys[start_index..end_index]
            .iter()
            .map(|(_, post_key)| post_key.clone())
            .collect();

        Ok(selected_post_keys)
    }

    pub async fn from_listed_post_ids(
        viewer_id: Option<String>,
        post_keys: &[String],
    ) -> Result<Option<Self>, Box<dyn std::error::Error + Send + Sync>> {
        // TODO: potentially we could use a new redis_com.mget() with a single call to retrieve all
        // post views at once and build the postss on the fly.
        // But still, using tokio to create them concurrently has VERY high performance.
        let viewer_id = viewer_id.map(|id| id.to_string());
        let mut handles = Vec::with_capacity(post_keys.len());

        for post_key in post_keys {
            let (author_id, post_id) = post_key.split_once(':').unwrap_or_default();
            let author_id = author_id.to_string();
            let viewer_id = viewer_id.clone();
            let post_id = post_id.to_string();
            let handle = spawn(async move {
                PostView::get_by_id(&author_id, &post_id, viewer_id.as_deref()).await
            });
            handles.push(handle);
        }

        let mut post_views = Vec::with_capacity(post_keys.len());

        for handle in handles {
            if let Some(post_view) = handle.await?? {
                post_views.push(post_view);
            }
        }

        Ok(Some(Self(post_views)))
    }

    /// Adds the post to a Redis sorted set using the `indexed_at` timestamp as the score.
    pub async fn add_to_timeline_sorted_set(
        details: &PostDetails,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let element = format!("{}:{}", details.author, details.id);
        let score = details.indexed_at as f64;
        Self::put_index_sorted_set(&POST_TIMELINE_KEY_PARTS, &[(score, element.as_str())]).await
    }

    /// Adds the post to a Redis sorted set using the `indexed_at` timestamp as the score.
    pub async fn add_to_per_user_sorted_set(
        details: &PostDetails,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let key_parts = [&POST_PER_USER_KEY_PARTS[..], &[details.author.as_str()]].concat();
        let score = details.indexed_at as f64;
        Self::put_index_sorted_set(&key_parts, &[(score, details.id.as_str())]).await
    }

    /// Adds a bookmark to Redis sorted set using the `indexed_at` timestamp as the score.
    pub async fn add_to_bookmarks_sorted_set(
        bookmark: &Bookmark,
        bookmarker_id: &str,
        post_id: &str,
        author_id: &str,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let key_parts = [&BOOKMARKS_USER_KEY_PARTS[..], &[bookmarker_id]].concat();
        let post_key = format!("{}:{}", author_id, post_id);
        let score = bookmark.indexed_at as f64;
        Self::put_index_sorted_set(&key_parts, &[(score, post_key.as_str())]).await
    }

    /// Adds the post to a Redis sorted set using the total engagement as the score.
    pub async fn add_to_engagement_sorted_set(
        counts: &PostCounts,
        author_id: &str,
        post_id: &str,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let element = format!("{}:{}", author_id, post_id);
        let score = counts.tags + counts.replies + counts.reposts;
        let score = score as f64;

        Self::put_index_sorted_set(
            &POST_TOTAL_ENGAGEMENT_KEY_PARTS,
            &[(score, element.as_str())],
        )
        .await
    }
}
```
./src/models/post/view.rs
```
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use super::{Bookmark, PostCounts, PostDetails, PostRelationships};
use crate::models::tag::post::PostTags;

/// Represents a Pubky user with relational data including tags, counts, and relationship with a viewer.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct PostView {
    details: PostDetails,
    counts: PostCounts,
    tags: PostTags,
    relationships: PostRelationships,
    bookmark: Option<Bookmark>,
}

impl Default for PostView {
    fn default() -> Self {
        Self::new()
    }
}

impl PostView {
    pub fn new() -> Self {
        Self {
            details: PostDetails::new(),
            counts: PostCounts::new(),
            tags: PostTags::default(),
            relationships: PostRelationships::new(),
            bookmark: Some(Bookmark::new()),
        }
    }

    /// Retrieves a user ID, checking the cache first and then the graph database.
    pub async fn get_by_id(
        author_id: &str,
        post_id: &str,
        viewer_id: Option<&str>,
    ) -> Result<Option<Self>, Box<dyn std::error::Error + Send + Sync>> {
        // Perform all operations concurrently
        let (details, counts, bookmark, relationships, tags) = tokio::try_join!(
            PostDetails::get_by_id(author_id, post_id),
            PostCounts::get_by_id(author_id, post_id),
            Bookmark::get_by_id(author_id, post_id, viewer_id),
            PostRelationships::get_by_id(author_id, post_id),
            PostTags::get_by_id(author_id, post_id),
        )?;

        let details = match details {
            None => return Ok(None),
            Some(details) => details,
        };

        let counts = counts.unwrap_or_default();
        let relationships = relationships.unwrap_or_default();

        let tags = tags.unwrap_or_default();

        Ok(Some(Self {
            details,
            counts,
            bookmark,
            relationships,
            tags,
        }))
    }
}
```
./src/models/tag/user.rs
```
use std::ops::Deref;

use crate::db::connectors::neo4j::get_neo4j_graph;
use crate::queries;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use super::Tags;

/// Represents a tag that refers to the current user
#[derive(Serialize, Deserialize, ToSchema, Debug, Clone, Default)]
pub struct UserTag {
    pub label: String,
    tagged: Tags,
}

// Define a newtype wrapper
#[derive(Serialize, Deserialize, Debug, Clone, ToSchema, Default)]
pub struct UserTags(Vec<UserTag>);

// Implement Deref so TagList can be used like Vec<String>
impl Deref for UserTags {
    type Target = Vec<UserTag>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl UserTags {
    pub async fn get_by_id(
        user_id: &str,
    ) -> Result<Option<UserTags>, Box<dyn std::error::Error + Send + Sync>> {
        Self::get_from_graph(user_id).await
    }

    async fn get_from_graph(
        user_id: &str,
    ) -> Result<Option<UserTags>, Box<dyn std::error::Error + Send + Sync>> {
        let query = queries::user_tags(user_id);
        let graph = get_neo4j_graph()?;

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        if let Some(row) = result.next().await? {
            let user_exists: bool = row.get("user_exists").unwrap_or(false);
            if user_exists {
                let tagged_from: UserTags = row.get("user_tags").unwrap_or_default();
                return Ok(Some(tagged_from));
            }
        }
        Ok(None)
    }
}
```
./src/models/tag/mod.rs
```
use chrono::Utc;
use serde::{Deserialize, Serialize};
use std::ops::Deref;
use utoipa::ToSchema;

pub mod post;
pub mod user;
// Atomic struct to save in the cache
#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct Tag {
    tag_id: String, // TODO: Crobfordbase32 type
    indexed_at: i64,
    tagger_id: String,
}

impl Default for Tag {
    fn default() -> Self {
        Self {
            tag_id: String::new(),
            indexed_at: Utc::now().timestamp(),
            tagger_id: String::new(),
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema, Default)]
pub struct Tags(Vec<Tag>);

// Implement Deref so TagList can be used like Vec<String>
impl Deref for Tags {
    type Target = Vec<Tag>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```
./src/models/tag/post.rs
```
use std::ops::Deref;

use crate::db::connectors::neo4j::get_neo4j_graph;
use crate::queries;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use super::Tags;

/// Represents a tag that refers to the current user
#[derive(Serialize, Deserialize, ToSchema, Debug, Clone, Default)]
pub struct PostTag {
    pub label: String,
    tagged: Tags,
}

// Define a newtype wrapper
#[derive(Serialize, Deserialize, Debug, Clone, ToSchema, Default)]
pub struct PostTags(Vec<PostTag>);

// Implement Deref so TagList can be used like Vec<String>
impl Deref for PostTags {
    type Target = Vec<PostTag>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl PostTags {
    pub async fn get_by_id(
        user_id: &str,
        post_id: &str
    ) -> Result<Option<PostTags>, Box<dyn std::error::Error + Send + Sync>> {
        Self::get_from_graph(user_id, post_id).await
    }

    async fn get_from_graph(
        user_id: &str,
        post_id: &str
    ) -> Result<Option<PostTags>, Box<dyn std::error::Error + Send + Sync>> {
        let query = queries::post_tags(user_id, post_id);
        let graph = get_neo4j_graph()?;

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        if let Some(row) = result.next().await? {
            let user_exists: bool = row.get("post_exists").unwrap_or(false);
            if user_exists {
                let tagged_from: PostTags = row.get("post_tags").unwrap_or_default();
                return Ok(Some(tagged_from));
            }
        }
        Ok(None)
    }
}
```
./src/models/user/follows.rs
```
use crate::db::connectors::neo4j::get_neo4j_graph;
use crate::{queries, RedisOps};
use neo4rs::Query;
use axum::async_trait;
use serde::{Deserialize, Serialize};
use std::error::Error;
use utoipa::ToSchema;

#[async_trait]
pub trait UserFollows: Sized + RedisOps + AsRef<[String]> + Default {
    fn from_vec(vec: Vec<String>) -> Self;

    async fn get_by_id(
        user_id: &str,
        skip: Option<usize>,
        limit: Option<usize>,
    ) -> Result<Option<Self>, Box<dyn Error + Send + Sync>> {
        match Self::try_from_index_set(&[user_id], skip, limit).await? {
            Some(connections) => Ok(Some(Self::from_vec(connections))),
            None => Self::get_from_graph(user_id, skip, limit).await,
        }
    }

    async fn get_from_graph(
        user_id: &str,
        skip: Option<usize>,
        limit: Option<usize>,
    ) -> Result<Option<Self>, Box<dyn Error + Send + Sync>> {
        let graph = get_neo4j_graph()?;
        let query = Self::get_query(user_id, skip, limit);

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        if let Some(row) = result.next().await? {
            let user_exists: bool = row.get("user_exists").unwrap_or(false);
            if !user_exists {
                return Ok(None);
            }
            if let Some(connections) = row.get::<Option<Vec<String>>>(Self::get_ids_field_name())? {
                let connections = Self::from_vec(connections);
                connections.put_index_set(&[user_id]).await?;
                Ok(Some(connections))
            } else {
                Ok(Some(Self::default()))
            }
        } else {
            Ok(None)
        }
    }

    fn get_query(user_id: &str, skip: Option<usize>, limit: Option<usize>) -> Query;
    fn get_ids_field_name() -> &'static str;
}

#[derive(Serialize, Deserialize, ToSchema, Default)]
pub struct Followers(pub Vec<String>);

#[derive(Serialize, Deserialize, ToSchema, Default)]
pub struct Following(pub Vec<String>);

impl AsRef<[String]> for Followers {
    fn as_ref(&self) -> &[String] {
        &self.0
    }
}

impl AsRef<[String]> for Following {
    fn as_ref(&self) -> &[String] {
        &self.0
    }
}

#[async_trait]
impl RedisOps for Followers {}

#[async_trait]
impl RedisOps for Following {}

impl UserFollows for Followers {
    fn from_vec(vec: Vec<String>) -> Self {
        Self(vec)
    }

    fn get_query(user_id: &str, skip: Option<usize>, limit: Option<usize>) -> Query {
        queries::get_user_followers(user_id, skip, limit)
    }

    fn get_ids_field_name() -> &'static str {
        "follower_ids"
    }
}

impl UserFollows for Following {
    fn from_vec(vec: Vec<String>) -> Self {
        Self(vec)
    }

    fn get_query(user_id: &str, skip: Option<usize>, limit: Option<usize>) -> Query {
        queries::get_user_following(user_id, skip, limit)
    }

    fn get_ids_field_name() -> &'static str {
        "following_ids"
    }
}

#[derive(Serialize, Deserialize, ToSchema, Default)]
pub struct Friends(pub Vec<String>);

impl Friends {
    pub async fn get_by_id(
        user_id: &str,
        skip: Option<usize>,
        limit: Option<usize>,
    ) -> Result<Option<Self>, Box<dyn Error + Send + Sync>> {
        // Fetch following and followers, limit to 10K
        let following = Following::get_by_id(user_id, None, Some(10000))
            .await?
            .unwrap_or_default()
            .0;

        let followers = Followers::get_by_id(user_id, None, Some(10000))
            .await?
            .unwrap_or_default()
            .0;

        // Find intersection of following and followers (mutual friends)
        let mut friends: Vec<String> = following
            .into_iter()
            .filter(|user_id| followers.contains(user_id))
            .collect();

        if friends.is_empty() {
            return Ok(None);
        }

        if let Some(skip) = skip {
            friends = friends.into_iter().skip(skip).collect();
        }
        if let Some(limit) = limit {
            friends.truncate(limit);
        }

        Ok(Some(Self(friends)))
    }
}
```
./src/models/user/relationship.rs
```
use super::{Followers, UserFollows};
use crate::RedisOps;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

/// Represents the relationship of the user that views and user being viewed.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct Relationship {
    pub following: bool,
    pub followed_by: bool,
}

impl Default for Relationship {
    fn default() -> Self {
        Self::new()
    }
}

impl Relationship {
    pub fn new() -> Self {
        Self {
            following: false,
            followed_by: false,
        }
    }

    // Retrieves user-viewer relationship
    pub async fn get_by_id(
        user_id: &str,
        viewer_id: Option<&str>,
    ) -> Result<Option<Self>, Box<dyn std::error::Error + Send + Sync>> {
        match viewer_id {
            None => Ok(None),
            Some(v_id) => Self::try_from_index(user_id, v_id).await,
        }
    }

    /// Retrieves relationship from Followers/Following Redis index sets.
    pub async fn try_from_index(
        user_id: &str,
        viewer_id: &str,
    ) -> Result<Option<Relationship>, Box<dyn std::error::Error + Send + Sync>> {
        let user_key = [user_id];
        let viewer_key = [viewer_id];
        // Concurrently check if the viewer follows the user and if the user follows the viewer
        let ((user_id_followers_exist, following), (viewer_id_followers_exist, followed_by)) = tokio::try_join!(
            Followers::check_set_member(&user_key, viewer_id),
            Followers::check_set_member(&viewer_key, user_id)
        )?;

        if user_id_followers_exist && viewer_id_followers_exist {
            // If both sets exist, return the relationship
            return Ok(Some(Self {
                followed_by,
                following,
            }));
        };

        // Run a graph search for followers and populate index sets
        if !user_id_followers_exist {
            Followers::get_from_graph(user_id, None, None).await?;
        }
        if !viewer_id_followers_exist {
            Followers::get_from_graph(viewer_id, None, None).await?;
        }

        // Recheck the relationships after ensuring the data is populated
        let (user_recheck, viewer_recheck) = tokio::try_join!(
            Followers::check_set_member(&user_key, viewer_id),
            Followers::check_set_member(&viewer_key, user_id)
        )?;
        let (user_exist, following) = user_recheck;
        let (viewer_exist, followed_by) = viewer_recheck;

        if !user_exist || !viewer_exist {
            return Ok(None);
        }

        Ok(Some(Self {
            followed_by,
            following,
        }))
    }
}
```
./src/models/user/tags.rs
```
use super::UserDetails;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

/// Represents a tag with its tag label, count, and author sources.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct ProfileTag {
    label: String,
    count: u32,
    by: Vec<UserDetails>,
}

impl Default for ProfileTag {
    fn default() -> Self {
        Self::new()
    }
}

impl ProfileTag {
    pub fn new() -> Self {
        Self {
            label: String::new(),
            count: 0,
            by: vec![UserDetails::default()],
        }
    }
}

/// Represents a collection of ProfileTag.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct UserTags {
    tags: Vec<ProfileTag>,
}

impl Default for UserTags {
    fn default() -> Self {
        Self::new()
    }
}

impl UserTags {
    pub fn new() -> Self {
        Self { tags: Vec::new() }
    }

    /// TODO: Retrieves tags by user ID, currently returns an empty instance.
    pub async fn get_by_id(_user_id: &str) -> Result<Option<Self>, Box<dyn std::error::Error>> {
        Ok(Some(Self::new()))
    }
}
```
./src/models/user/mod.rs
```
mod counts;
mod details;
mod follows;
mod relationship;
mod stream;
mod tags;
mod view;

pub use counts::UserCounts;
pub use details::{UserLink, UserDetails};
pub use follows::{Followers, Following, Friends, UserFollows};
pub use relationship::Relationship;
pub use stream::{UserStream, UserStreamType};
pub use tags::ProfileTag;
pub use tags::UserTags;
pub use view::UserView;
```
./src/models/user/details.rs
```
use crate::models::traits::Collection;
use crate::{queries, RedisOps};
use axum::async_trait;
use neo4rs::Query;
use serde::{Deserialize, Serialize, Deserializer};
use utoipa::ToSchema;
use serde_json;

/// Represents a user's single link with a title and URL.
#[derive(Serialize, Deserialize, ToSchema, Default, Clone, Debug)]
pub struct UserLink {
    title: String,
    url: String,
}

impl UserLink {
    pub fn new() -> Self {
        Self {
            title: String::new(),
            url: String::new(),
        }
    }
}

#[async_trait]
impl RedisOps for UserDetails {
    async fn prefix() -> String {
        String::from("User:Details")
    }
}

#[async_trait]
impl Collection for UserDetails {
    fn graph_query(id_list: &[&str]) -> Query {
        queries::get_users_details_by_ids(id_list)
    }
}

/// Represents user data with name, bio, image, links, and status.
#[derive(Serialize, Deserialize, ToSchema, Default, Clone, Debug)]
pub struct UserDetails {
    name: String,
    bio: String,
    id: String,
    #[serde(deserialize_with = "deserialize_user_links")]
    links: Vec<UserLink>,
    status: String,
    indexed_at: i64,
}

fn deserialize_user_links<'de, D>(deserializer: D) -> Result<Vec<UserLink>, D::Error>
where
    D: Deserializer<'de>,
{
    let s: String = String::deserialize(deserializer)?;
    let urls: Vec<UserLink> = serde_json::from_str(&s).map_err(serde::de::Error::custom)?;
    Ok(urls)
}

impl UserDetails {
    /// Retrieves details by user ID, first trying to get from Redis, then from Neo4j if not found.
    pub async fn get_by_id(
        user_id: &str,
    ) -> Result<Option<UserDetails>, Box<dyn std::error::Error + Send + Sync>> {
        // Delegate to UserDetailsCollection::get_by_ids for single item retrieval
        let details_collection = Self::get_by_ids(&[user_id]).await?;
        Ok(details_collection.into_iter().flatten().next())
    }
}

#[cfg(test)]
mod tests {
    use crate::{setup, Config};

    use super::*;

    const USER_IDS: [&str; 8] = [
        "4snwyct86m383rsduhw5xgcxpw7c63j3pq8x4ycqikxgik8y64ro",
        "3iwsuz58pgrf7nw4kx8mg3fib1kqyi4oxqmuqxzsau1mpn5weipo",
        "3qgon1apkcmp63xbqpkrb3zzrja3nq9wou4u5bf7uu8rc9ehfo3y",
        "nope_it_does_not_exist", // Does not exist
        "4nacrqeuwh35kwrziy4m376uuyi7czazubgtyog4adm77ayqigxo",
        "5g3fwnue819wfdjwiwm8qr35ww6uxxgbzrigrtdgmbi19ksioeoy",
        "4p1qa1ko7wuta4f1qm8io495cqsmefbgfp85wtnm9bj55gqbhjpo",
        "not_existing_user_id_either", // Does not exist
    ];

    #[tokio::test]
    async fn test_get_by_ids_from_redis() {
        let config = Config::from_env();
        setup(&config).await;

        let user_details = UserDetails::get_by_ids(&USER_IDS)
            .await
            .unwrap();
        assert_eq!(user_details.len(), USER_IDS.len());

        for details in user_details[0..3].iter() {
            assert!(details.is_some());
        }
        for details in user_details[4..7].iter() {
            assert!(details.is_some());
        }
        assert!(user_details[3].is_none());
        assert!(user_details[7].is_none());

        assert_eq!(user_details[0].as_ref().unwrap().name, "Aldert");
        assert_eq!(user_details[5].as_ref().unwrap().name, "Flavio");

        assert_eq!(user_details[5].as_ref().unwrap().links.len(), 4);
        assert_eq!(user_details[0].as_ref().unwrap().links.len(), 2);

        for (i, details) in user_details.iter().enumerate() {
            if let Some(details) = details {
                assert_eq!(details.id, USER_IDS[i]);
            }
        }
    }
}
```
./src/models/user/counts.rs
```
use crate::db::connectors::neo4j::get_neo4j_graph;
use crate::{queries, RedisOps};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use super::UserStream;

/// Represents total counts of relationships of a user.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct UserCounts {
    pub tags: u32,
    pub posts: u32,
    pub following: u32,
    pub followers: u32,
    pub friends: u32,
}

impl RedisOps for UserCounts {}

impl Default for UserCounts {
    fn default() -> Self {
        Self::new()
    }
}

impl UserCounts {
    pub fn new() -> Self {
        Self {
            tags: 0,
            posts: 0,
            followers: 0,
            following: 0,
            friends: 0,
        }
    }

    /// Retrieves counts by user ID, first trying to get from Redis, then from Neo4j if not found.
    pub async fn get_by_id(
        user_id: &str,
    ) -> Result<Option<UserCounts>, Box<dyn std::error::Error + Send + Sync>> {
        match Self::try_from_index_json(&[user_id]).await? {
            Some(counts) => Ok(Some(counts)),
            None => Self::get_from_graph(user_id).await,
        }
    }

    /// Retrieves the counts from Neo4j.
    pub async fn get_from_graph(
        user_id: &str,
    ) -> Result<Option<UserCounts>, Box<dyn std::error::Error + Send + Sync>> {
        let graph = get_neo4j_graph()?;
        let query = queries::user_counts(user_id);

        let graph = graph.lock().await;
        let mut result = graph.execute(query).await?;

        if let Some(row) = result.next().await? {
            if !row.get("user_exists").unwrap_or(false) {
                return Ok(None);
            }
            let counts = Self {
                following: row.get("following_count").unwrap_or_default(),
                followers: row.get("followers_count").unwrap_or_default(),
                friends: row.get("friends_count").unwrap_or_default(),
                posts: row.get("posts_count").unwrap_or_default(),
                tags: row.get("tags_count").unwrap_or_default(),
            };
            counts.put_index_json(&[user_id]).await?;
            UserStream::add_to_mostfollowed_sorted_set(user_id, &counts).await?;
            Ok(Some(counts))
        } else {
            Ok(None)
        }
    }
}
```
./src/models/user/stream.rs
```
use std::error::Error;

use super::{Followers, Following, Friends, UserFollows, UserCounts, UserView};
use crate::{db::kv::index::sorted_sets::Sorting, RedisOps};
use serde::{Deserialize, Serialize};
use tokio::task::spawn;
use utoipa::ToSchema;

const USER_MOSTFOLLOWED_KEY_PARTS: [&str; 2] = ["Users", "MostFollowed"];

#[derive(Deserialize, ToSchema)]
pub enum UserStreamType {
    Followers,
    Following,
    Friends,
    MostFollowed,
}

#[derive(Serialize, Deserialize, ToSchema)]
pub struct UserStream(Vec<UserView>);

impl RedisOps for UserStream {}

impl Default for UserStream {
    fn default() -> Self {
        Self::new()
    }
}

impl UserStream {
    pub fn new() -> Self {
        Self(Vec::new())
    }

    pub async fn get_by_id(
        user_id: &str,
        viewer_id: Option<&str>,
        skip: Option<usize>,
        limit: Option<usize>,
        list_type: UserStreamType,
    ) -> Result<Option<Self>, Box<dyn Error + Send + Sync>> {
        let user_ids = match list_type {
            UserStreamType::Followers => Followers::get_by_id(user_id, skip, limit)
                .await?
                .map(|followers| followers.0),
            UserStreamType::Following => Following::get_by_id(user_id, skip, limit)
                .await?
                .map(|following| following.0),
            UserStreamType::Friends => Friends::get_by_id(user_id, skip, limit)
                .await?
                .map(|following| following.0),
            UserStreamType::MostFollowed => Self::try_from_index_sorted_set(
                &USER_MOSTFOLLOWED_KEY_PARTS,
                None,
                None,
                skip,
                limit,
                Sorting::Descending,
            )
            .await?
            .map(|set| set.into_iter().map(|(user_id, _score)| user_id).collect()),
        };
        match user_ids {
            Some(users) => Self::from_listed_user_ids(&users, viewer_id).await,
            None => Ok(None),
        }
    }

    pub async fn from_listed_user_ids(
        user_ids: &[String],
        viewer_id: Option<&str>,
    ) -> Result<Option<Self>, Box<dyn std::error::Error + Send + Sync>> {
        // TODO: potentially we could use a new redis_com.mget() with a single call to retrieve all
        // user details at once and build the user profiles on the fly.
        // But still, using tokio to create them concurrently has VERY high performance.
        let viewer_id = viewer_id.map(|id| id.to_string());
        let mut handles = Vec::with_capacity(user_ids.len());

        for user_id in user_ids {
            let user_id = user_id.clone();
            let viewer_id = viewer_id.clone();
            let handle =
                spawn(async move { UserView::get_by_id(&user_id, viewer_id.as_deref()).await });
            handles.push(handle);
        }

        let mut user_views = Vec::with_capacity(user_ids.len());

        for handle in handles {
            if let Some(user_view) = handle.await?? {
                user_views.push(user_view);
            }
        }

        Ok(Some(Self(user_views)))
    }

    /// Adds the post to a Redis sorted set using the follower counts as score.
    pub async fn add_to_mostfollowed_sorted_set(
        user_id: &str,
        counts: &UserCounts,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        Self::put_index_sorted_set(
            &USER_MOSTFOLLOWED_KEY_PARTS,
            &[(counts.followers as f64, user_id)],
        )
        .await
    }
}
```
./src/models/user/view.rs
```
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use super::{Relationship, UserCounts, UserDetails};
use crate::models::tag::user::UserTags;

/// Represents a Pubky user with relational data including tags, counts, bookmark and relationship with other posts.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct UserView {
    details: UserDetails,
    counts: UserCounts,
    pub tags: UserTags,
    viewer: Relationship,
}

impl Default for UserView {
    fn default() -> Self {
        Self::new()
    }
}

impl UserView {
    pub fn new() -> Self {
        Self {
            details: UserDetails::default(),
            counts: UserCounts::new(),
            tags: UserTags::default(),
            viewer: Relationship::new(),
        }
    }

    /// Retrieves a user by ID, checking the cache first and then the graph database.
    pub async fn get_by_id(
        user_id: &str,
        viewer_id: Option<&str>,
    ) -> Result<Option<Self>, Box<dyn std::error::Error + Send + Sync>> {
        // Perform all operations concurrently
        let (details, counts, viewer, tags) = tokio::try_join!(
            UserDetails::get_by_id(user_id),
            UserCounts::get_by_id(user_id),
            Relationship::get_by_id(user_id, viewer_id),
            UserTags::get_by_id(user_id)
        )?;

        let details = match details {
            None => return Ok(None),
            Some(details) => details,
        };

        let counts = counts.unwrap_or_default();
        let viewer = viewer.unwrap_or_default();

        let tags = tags.unwrap_or_default();

        Ok(Some(Self {
            details,
            counts,
            viewer,
            tags,
        }))
    }
}
```
./src/models/info.rs
```
use serde::Serialize;
use utoipa::ToSchema;

use crate::db::kv::last_save::get_last_rdb_save_time;

#[derive(Serialize, ToSchema)]
pub struct ServerInfo {
    pub description: String,
    pub homepage: String,
    pub license: String,
    pub name: String,
    pub repository: String,
    pub version: String,
    pub last_index_snapshot: u64,
}

impl ServerInfo {
    pub async fn new() -> Self {
        let last_index_snapshot = get_last_rdb_save_time().await.unwrap_or_default();
        Self {
            description: env!("CARGO_PKG_DESCRIPTION").to_string(),
            homepage: env!("CARGO_PKG_HOMEPAGE").to_string(),
            license: env!("CARGO_PKG_LICENSE").to_string(),
            name: env!("CARGO_PKG_NAME").to_string(),
            repository: env!("CARGO_PKG_REPOSITORY").to_string(),
            version: env!("CARGO_PKG_VERSION").to_string(),
            last_index_snapshot,
        }
    }
}
```
./Cargo.toml
```
[package]
name = "pubky-nexus"
version = "0.1.0"
edition = "2021"
description = "Nexus between homeservers and Pubky-App. Pubky-nexus constructs a social graph out of all of the events on pubky-core homeservers and exposes a social-media-like API capable of powerful Web-of-Trust inference."
homepage = "https://github.com/pubky"
repository = "https://github.com/pubky/pubky-nexus"
license = "MIT"
default-run = "service"

[dependencies]
tokio = { version = "1.39.2", features = ["full"] }
axum = "0.7.5"
redis = { version = "0.26.1", features = ["tokio-comp", "json"] }
neo4rs = "0.8.0"
serde = { version = "1.0.207", features = ["derive"] }
serde_json = "1.0.124"
once_cell = "1.19.0"
utoipa = "4.2.3"
utoipa-swagger-ui = { version = "7.1.0", features = ["axum"] }
tower-http = { version = "0.5.2", features = ["fs"] }
dotenv = "0.15"
log = "0.4.22"
env_logger = "0.11.5"
const_format = "0.2.32"
thiserror = "1.0.63"
chrono = "0.4.38"
pkarr = { version = "2.1.2", features = ["async"], default-features = false }

[dev-dependencies]
anyhow = "1.0.86"
httpc-test = "0.1.10"
criterion = { version = "0.5.1", features = ["async_tokio"] }

[lib]
name = "pubky_nexus"
path = "src/lib.rs"

[[bin]]

name = "service"
path = "src/service.rs"

[[bin]]
name = "watcher"
path = "src/watcher.rs"

[[bench]]
name = "user"
harness = false

[[bench]]
name = "tag"
harness = false

[[bench]]
name = "post"
harness = false

[[bench]]
name = "reindex"
harness = false

[[bench]]
name = "follows"
harness = false

[[bench]]
name = "stream"
harness = false


# Max performance profile
[profile.release]
opt-level = 3
codegen-units = 1
lto = true
incremental = false
```
