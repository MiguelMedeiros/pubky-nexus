./watcher/src/main.rs
```
// TODO: Research if that one is the best approach
// Maybe here we can create an POST endpoint that fakes the event stream
// After with mpsc (Multiple Producer Single Consumer) broadcast the event
// to all consumers. In our case, graph and kv
fn main() {
    println!("Hello, world!");
}
```
./watcher/src/kv/consumer.rs
```
// Reads all the events from the event store
```
./watcher/src/kv/mod.rs
```
pub mod consumer;
pub mod queries;
```
./watcher/src/kv/queries.rs
```
// Write queries to create the data layer of the app
```
./watcher/src/graph/consumer.rs
```
// Reads all the events from the event store
```
./watcher/src/graph/mod.rs
```
pub mod consumer;
pub mod queries;
```
./watcher/src/graph/queries.rs
```
// Write queries to create the data layer of the app
```
./watcher/src/lib.rs
```
pub mod graph;
pub mod kv;
```
./watcher/Cargo.toml
```
[package]
name = "pk-social-watcher"
version = "0.1.0"
edition = "2021"

[dependencies]
```
./service/src/main.rs
```
use tokio::net::TcpListener;
use utoipa::OpenApi;
use utoipa_swagger_ui::SwaggerUi;

mod config;
mod error;
mod models;
mod routes;
mod setup;

pub use self::error::{Error, Result};

#[tokio::main]
async fn main() {
    let config = config::Config::from_env();
    setup::setup(&config).await;

    // Routes
    let routes_v0 = routes::v0::routes();
    let route_static = routes::r#static::routes(&config.static_path);

    let app = routes_v0.merge(route_static).merge(
        SwaggerUi::new("/swagger-ui").url("/api-docs/openapi.json", routes::v0::ApiDoc::openapi()),
    );

    // Start server
    let listener = TcpListener::bind(&config.server_binding()).await.unwrap();
    println!("->> LISTENING on {:?}\n", listener.local_addr());
    axum::serve(listener, app.into_make_service())
        .await
        .unwrap();
}
```
./service/src/routes/static/mod.rs
```
use axum::{routing::get_service, Router};
use tower_http::services::ServeDir;

pub fn routes(static_path: &String) -> Router {
    Router::new().nest_service("/static", get_service(ServeDir::new(static_path)))
}
```
./service/src/routes/mod.rs
```
pub mod r#static;
pub mod v0;
```
./service/src/routes/v0/profile/mod.rs
```
use crate::models::profile::Profile;
use axum::extract::{Path, Query};
use axum::response::{IntoResponse, Response};
use axum::Json;
use serde::Deserialize;

#[derive(Deserialize)]
pub struct ProfileQuery {
    viewer_id: Option<String>,
}

#[utoipa::path(
    get,
    path = "/v0/profiles/{user_id}",
    params(
        ("user_id" = String, Path, description = "User ID"),
        ("viewer_id" = Option<String>, Query, description = "Viewer ID")
    ),
    responses(
        (status = 200, description = "User profile", body = Profile),
        (status = 404, description = "User not found"),
        (status = 500, description = "Internal server error")
    )
)]
pub async fn get_profile(
    Path(user_id): Path<String>,
    Query(query): Query<ProfileQuery>,
) -> Result<Json<Profile>, Response> {
    match Profile::get_by_id(&user_id, query.viewer_id.as_deref()).await {
        Ok(Some(profile)) => Ok(Json(profile)),
        Ok(None) => Err((axum::http::StatusCode::NOT_FOUND, "User not found").into_response()),
        Err(_) => Err((
            axum::http::StatusCode::INTERNAL_SERVER_ERROR,
            "Internal server error",
        )
            .into_response()),
    }
}
```
./service/src/routes/v0/info/mod.rs
```
use super::endpoints::INFO_ROUTE;
use crate::models::info::ServerInfo;
use axum::response::IntoResponse;
use axum::Json;

#[utoipa::path(
    get,
    path = INFO_ROUTE,
    responses(
        (status = 200, description = "Server info", body = ServerInfo)
    )
)]
pub async fn info_handler() -> impl IntoResponse {
    let info = ServerInfo::new();
    Json(info)
}
```
./service/src/routes/v0/mod.rs
```
use axum::routing::get;
use axum::Router;
use endpoints::{INFO_ROUTE, USER_PROFILE_ROUTE};
use utoipa::OpenApi;

use crate::models::{info::ServerInfo, profile::Profile};

pub mod endpoints;
pub mod info;
pub mod profile;

pub fn routes() -> Router {
    Router::new()
        .route(INFO_ROUTE, get(info::info_handler))
        .route(USER_PROFILE_ROUTE, get(profile::get_profile))
}

#[derive(OpenApi)]
#[openapi(
    paths(info::info_handler, profile::get_profile),
    components(schemas(ServerInfo, Profile))
)]
pub struct ApiDoc;
```
./service/src/routes/v0/endpoints.rs
```
// Info routes
pub const INFO_ROUTE: &str = "/v0/info";

// Profile routes
// TODO: try using route prefixes: pub const PROFILE_ROUTE: &str = "/v0/profile";
pub const USER_PROFILE_ROUTE: &str = "/v0/profile/:user_id";
```
./service/src/setup.rs
```
use crate::config::Config;
use pk_social_common::connectors::{
    neo4j::{Neo4jConnector, NEO4J_CONNECTOR},
    redis::{RedisConnector, REDIS_CONNECTOR},
};

pub async fn setup(config: &Config) {
    // Initialize Neo4j connection
    let neo4j_connector = Neo4jConnector::new_connection(
        &config.neo4j_uri(),
        &config.neo4j_username,
        &config.neo4j_password,
    )
    .await
    .expect("Failed to connect to Neo4j");

    NEO4J_CONNECTOR
        .set(neo4j_connector)
        .expect("Failed to set global Neo4j connector");

    // Initialize Redis connection
    let redis_connector = RedisConnector::new_connection(&config._redis_uri())
        .await
        .expect("Failed to connect to Redis");

    REDIS_CONNECTOR
        .set(redis_connector)
        .expect("Failed to set global Redis connector");
}
```
./service/src/lib.rs
```
// lib crate only needed for benchmarking with Criterion
pub mod config;
pub mod error;
pub mod models;
pub mod routes;
pub mod setup;

pub use error::{Error, Result};
```
./service/src/config.rs
```
use dotenv::dotenv;
use std::env;

#[derive(Debug, Clone)]
pub struct Config {
    neo4j_host: String,
    neo4j_port: String,
    pub neo4j_username: String,
    pub neo4j_password: String,
    _redis_host: String,
    _redis_port: String,
    pub static_path: String,
    server_host: String,
    server_port: String,
}

impl Config {
    pub fn from_env() -> Self {
        dotenv().ok();

        Self {
            neo4j_host: env::var("NEO4J_HOST").unwrap_or_else(|_| "localhost".to_string()),
            neo4j_port: env::var("NEO4J_PORT").unwrap_or_else(|_| "7687".to_string()),
            neo4j_username: env::var("NEO4J_DB_USERNAME").expect("NEO4J_DB_USERNAME not set"),
            neo4j_password: env::var("NEO4J_PASSWORD").expect("NEO4J_PASSWORD not set"),
            _redis_host: env::var("REDIS_HOST").unwrap_or_else(|_| "localhost".to_string()),
            _redis_port: env::var("REDIS_PORT").unwrap_or_else(|_| "6379".to_string()),
            static_path: env::var("STATIC_PATH").unwrap_or_else(|_| "./".to_string()),
            server_host: env::var("SERVER_HOST").unwrap_or_else(|_| "127.0.0.1".to_string()),
            server_port: env::var("SERVER_PORT").unwrap_or_else(|_| "8080".to_string()),
        }
    }

    pub fn neo4j_uri(&self) -> String {
        format!("bolt://{}:{}", self.neo4j_host, self.neo4j_port)
    }

    pub fn _redis_uri(&self) -> String {
        format!("redis://{}:{}", self._redis_host, self._redis_port)
    }

    pub fn server_binding(&self) -> String {
        format!("{}:{}", self.server_host, self.server_port)
    }
}
```
./service/src/error.rs
```
use axum::http::StatusCode;
use axum::response::{IntoResponse, Response};
use serde::Serialize;

pub type Result<T> = core::result::Result<T, Error>;

#[derive(Clone, Debug, Serialize)]
pub enum Error {
    UserNotFound,
}

impl IntoResponse for Error {
    fn into_response(self) -> Response {
        println!("->> {:<12} - {self:?}", "INTO_RES");

        // Create a placeholder Axum response.
        let mut response = StatusCode::INTERNAL_SERVER_ERROR.into_response();

        // Insert the Error into the response.
        response.extensions_mut().insert(self);

        response
    }
}

impl core::fmt::Display for Error {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::result::Result<(), core::fmt::Error> {
        write!(fmt, "{self:?}")
    }
}

impl std::error::Error for Error {}
```
./service/src/models/relationship.rs
```
use pk_social_common::connectors::{
    neo4j::get_neo4j_graph,
    redis::{get_redis_conn, AsyncCommands},
};
use pk_social_common::queries;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

const RELATIONSHIP_PREFIX: &str = "follows!";

/// Represents the relationship of the user that views and user being viewed.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct Relationship {
    pub following: bool,
    pub followed_by: bool,
}

impl Default for Relationship {
    fn default() -> Self {
        Self::new()
    }
}

impl Relationship {
    pub fn new() -> Self {
        Self {
            following: false,
            followed_by: false,
        }
    }

    /// Retrieves a relationship by user ids, checking the cache first and then the graph database.
    pub async fn get(
        user_id: &str,
        viewer_id: &str,
    ) -> Result<Option<Self>, Box<dyn std::error::Error>> {
        // Try to get from indexed cache
        if let Some(indexed_relationship) = Self::get_from_index(user_id, viewer_id).await? {
            // println!("Found relationship index {user_id}&{viewer_id}");
            return Ok(Some(indexed_relationship));
        }

        // Fallback to query from graph
        Self::get_from_graph(user_id, viewer_id).await
    }

    /// Indexes the relationship in Redis.
    pub async fn set_index(
        user_id: &str,
        viewer_id: &str,
        relationship: &Relationship,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut redis_conn = get_redis_conn().await?;

        if relationship.followed_by {
            let key = format!("{RELATIONSHIP_PREFIX}{user_id}{viewer_id}");
            // println!("Saved relationship  index {key}");
            redis_conn.set_ex(key, true, 3600).await?;
        }
        if relationship.following {
            let key = format!("{RELATIONSHIP_PREFIX}{viewer_id}{user_id}");
            redis_conn.set_ex(key, true, 3600).await?;
        }

        Ok(())
    }

    /// Retrieves the relationship from Redis.
    pub async fn get_from_index(
        user_id: &str,
        viewer_id: &str,
    ) -> Result<Option<Relationship>, Box<dyn std::error::Error>> {
        let mut redis_conn = get_redis_conn().await?;

        let following_key = format!("{RELATIONSHIP_PREFIX}{viewer_id}{user_id}");
        let followed_by_key = format!("{RELATIONSHIP_PREFIX}{user_id}{viewer_id}");

        let following_result: Option<bool> = redis_conn.get(following_key).await?;
        let followed_by_result: Option<bool> = redis_conn.get(followed_by_key).await?;

        match (following_result, followed_by_result) {
            (Some(following), Some(followed_by)) => Ok(Some(Relationship {
                following,
                followed_by,
            })),
            (None, None) => Ok(None),
            (Some(following), None) => Ok(Some(Relationship {
                following,
                followed_by: false,
            })),
            (None, Some(followed_by)) => Ok(Some(Relationship {
                following: false,
                followed_by,
            })),
        }
    }

    /// Retrieves the relationship from Neo4j and indexes it in Redis.
    pub async fn get_from_graph(
        user_id: &str,
        viewer_id: &str,
    ) -> Result<Option<Relationship>, Box<dyn std::error::Error>> {
        let graph = get_neo4j_graph()?;

        let viewer_relationship_query = queries::viewer_relationship(user_id, viewer_id);
        let graph = graph.lock().await;
        let mut result = graph.execute(viewer_relationship_query).await?;

        if let Some(row) = result.next().await? {
            let relationship = Relationship {
                following: row.get("following").unwrap_or(false),
                followed_by: row.get("followed_by").unwrap_or(false),
            };
            Relationship::set_index(user_id, viewer_id, &relationship).await?;
            Ok(Some(relationship))
        } else {
            Ok(None)
        }
    }
}
```
./service/src/models/profile.rs
```
use pk_social_common::{
    connectors::{
        neo4j::{get_neo4j_graph, Node},
        redis::{get_redis_conn, AsyncCommands},
    },
    queries,
};
use serde::{Deserialize, Serialize};
use tokio::join;
use utoipa::ToSchema;

use super::relationship::Relationship;

const PROFILE_PREFIX: &str = "profile!";

#[derive(Serialize, Deserialize, ToSchema)]
pub struct Link {
    title: String,
    url: String,
}

impl Default for Link {
    fn default() -> Self {
        Self::new()
    }
}

/// Represents a profile link with a title and URL.
impl Link {
    pub fn new() -> Self {
        Self {
            title: String::new(),
            url: String::new(),
        }
    }
}

/// Represents profile data with name, bio, image, links, and status.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct ProfileData {
    name: String,
    bio: String,
    image: String,
    links: Vec<Link>,
    status: String,
}

impl Default for ProfileData {
    fn default() -> Self {
        Self::new()
    }
}

impl ProfileData {
    pub fn new() -> Self {
        Self {
            name: String::new(),
            bio: String::new(),
            image: String::new(),
            links: vec![Link::new()],
            status: String::new(),
        }
    }

    /// Creates a `ProfileData` instance from a Neo4j `Node`.
    pub fn from_node(node: &Node) -> Self {
        Self {
            name: node.get("name").unwrap_or_default(),
            bio: node.get("bio").unwrap_or_default(),
            image: node.get("image").unwrap_or_default(),
            status: node.get("status").unwrap_or_default(),
            // links: node.get("links").unwrap_or_default(), // do not yet exist on neo4j-example
            links: vec![Link::new()],
        }
    }
}

/// Represents a tag author with a URI, ID, and profile data.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct Author {
    uri: String,
    id: String,
    profile: ProfileData,
}

impl Default for Author {
    fn default() -> Self {
        Self::new()
    }
}

impl Author {
    pub fn new() -> Self {
        Self {
            uri: String::new(),
            id: String::new(),
            profile: ProfileData::new(),
        }
    }
}

/// Represents a Tag source with an author, creation time, indexing time, and ID.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct From {
    author: Author,
    created_at: i64,
    indexed_at: i64,
    id: String,
}

impl Default for From {
    fn default() -> Self {
        Self::new()
    }
}

impl From {
    pub fn new() -> Self {
        Self {
            author: Author::new(),
            created_at: 0,
            indexed_at: 0,
            id: String::new(),
        }
    }
}

/// Represents a tag with it's tag label, count, and author sources.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct Tag {
    tag: String,
    count: u32,
    from: Vec<From>,
}

impl Default for Tag {
    fn default() -> Self {
        Self::new()
    }
}

impl Tag {
    pub fn new() -> Self {
        Self {
            tag: String::new(),
            count: 0,
            from: vec![From::new()],
        }
    }
}

/// Represents a Pubky user profile with relational data including tags, counts, and relationship with a viewer.
#[derive(Serialize, Deserialize, ToSchema)]
pub struct Profile {
    profile: ProfileData,
    tags_count: u32,
    posts_count: u32,
    followers_count: u32,
    following_count: u32,
    friends_count: u32,
    tagged_as: Vec<Tag>,
    viewer: Relationship,
}

impl Default for Profile {
    fn default() -> Self {
        Self::new()
    }
}

impl Profile {
    pub fn new() -> Self {
        Self {
            profile: ProfileData::new(),
            tags_count: 0,
            posts_count: 0,
            followers_count: 0,
            following_count: 0,
            friends_count: 0,
            tagged_as: vec![Tag::new()],
            viewer: Relationship::new(),
        }
    }

    /// Retrieves a profile by user ID, checking the cache first and then the graph database.
    pub async fn get_by_id(
        user_id: &str,
        viewer_id: Option<&str>,
    ) -> Result<Option<Self>, Box<dyn std::error::Error>> {
        // TODO: Concurrent relationship and profile retrieval
        // Get the relationship information
        let relationship = match viewer_id {
            Some(v_id) => Relationship::get(user_id, v_id).await?.unwrap_or_default(),
            None => Relationship::new(),
        };

        // Try to get from indexed cache
        if let Some(mut indexed_profile) = Self::get_from_index(user_id).await? {
            indexed_profile.viewer = relationship;
            return Ok(Some(indexed_profile));
        }

        // Fallback to query from graph
        match Self::get_from_graph(user_id).await? {
            Some(mut profile) => {
                profile.viewer = relationship;
                Ok(Some(profile))
            }
            None => Ok(None),
        }
    }

    /// Retrieves a profile from Neo4j, processes various queries, and caches the result in Redis.
    async fn get_from_index(user_id: &str) -> Result<Option<Self>, Box<dyn std::error::Error>> {
        let mut redis_conn = get_redis_conn().await?;
        let cache_key = format!("{PROFILE_PREFIX}{user_id}");

        if let Ok(cached_profile) = redis_conn.get::<_, String>(&cache_key).await {
            let profile: Profile = serde_json::from_str(&cached_profile)?;

            // println!("Found profile index {cache_key}");
            return Ok(Some(profile));
        }

        Ok(None)
    }

    /// Retrieves a profile from Neo4j, processes various queries, and caches the result in Redis.
    async fn get_from_graph(user_id: &str) -> Result<Option<Self>, Box<dyn std::error::Error>> {
        let graph = get_neo4j_graph()?;

        // Define all queries
        let user_query = queries::get_user_by_id(user_id);
        let follow_counts_query = queries::get_follow_counts(user_id);
        let tagged_as_query = queries::get_tagged_as(user_id);

        // Execute all queries concurrently
        let graph = graph.lock().await;
        let (user_result, follow_counts_result, tagged_as_result) = join!(
            graph.execute(user_query),
            graph.execute(follow_counts_query),
            graph.execute(tagged_as_query),
        );

        // Handle results
        let mut user_result = user_result?;
        let mut follow_counts_result = follow_counts_result?;
        let mut tagged_as_result = tagged_as_result?;

        // Exit early if user not found
        let user_row = if let Some(row) = user_result.next().await? {
            row
        } else {
            return Ok(None);
        };

        let mut profile = Self::new();
        let node: Node = user_row.get("u").unwrap();
        profile.profile = ProfileData::from_node(&node);

        // Process follow counts result
        if let Some(row) = follow_counts_result.next().await? {
            profile.following_count = row.get("following_count").unwrap_or_default();
            profile.followers_count = row.get("followers_count").unwrap_or_default();
            profile.friends_count = row.get("friends_count").unwrap_or_default();
        }

        // Process tagged as result
        while let Some(row) = tagged_as_result.next().await? {
            let tag: String = row.get("tag").unwrap_or_default();
            let count: u32 = row.get("count").unwrap_or_default();

            let authors: Vec<Author> = row
                .get::<Vec<Node>>("authors")
                .unwrap_or_default()
                .into_iter()
                .map(|author_node| Author {
                    uri: author_node.get("uri").unwrap_or_default(),
                    id: author_node.get("id").unwrap_or_default(),
                    profile: ProfileData::from_node(&author_node),
                })
                .collect();

            let tag_info = Tag {
                tag,
                count,
                from: authors
                    .into_iter()
                    .map(|author| From {
                        author,
                        created_at: 0,     // TODO: populate this field as needed
                        indexed_at: 0,     // TODO: populate this field as needed
                        id: String::new(), // TODO: populate this field as needed
                    })
                    .collect(),
            };

            profile.tagged_as.push(tag_info);
        }

        // Graph queries are expensive, so we save it to the index as cache.
        Self::set_index(user_id, &profile).await?;

        Ok(Some(profile))
    }

    /// Sets the profile in the Redis cache.
    async fn set_index(user_id: &str, profile: &Profile) -> Result<(), Box<dyn std::error::Error>> {
        let mut redis_conn = get_redis_conn().await?;
        let cache_key = format!("{PROFILE_PREFIX}{user_id}");

        let profile_json = serde_json::to_string(&profile)?;

        redis_conn.set_ex(&cache_key, profile_json, 3600).await?;
        // println!("Saved profile index {cache_key}");

        Ok(())
    }
}
```
./service/src/models/mod.rs
```
pub mod info;
pub mod profile;
pub mod relationship;
```
./service/src/models/info.rs
```
use serde::Serialize;
use utoipa::ToSchema;

#[derive(Serialize, ToSchema)]
pub struct ServerInfo {
    pub description: String,
    pub homepage: String,
    pub license: String,
    pub name: String,
    pub repository: String,
    pub version: String,
}

impl Default for ServerInfo {
    fn default() -> Self {
        Self::new()
    }
}

impl ServerInfo {
    pub fn new() -> Self {
        Self {
            description: env!("CARGO_PKG_DESCRIPTION").to_string(),
            homepage: env!("CARGO_PKG_HOMEPAGE").to_string(),
            license: env!("CARGO_PKG_LICENSE").to_string(),
            name: env!("CARGO_PKG_NAME").to_string(),
            repository: env!("CARGO_PKG_REPOSITORY").to_string(),
            version: env!("CARGO_PKG_VERSION").to_string(),
        }
    }
}
```
./service/tests/integration_tests.rs
```
use anyhow::Result;

const HOST_URL: &str = "http://localhost:8080";

#[tokio::test]
async fn test_info_endpoint() -> Result<()> {
    let client = httpc_test::new_client(HOST_URL)?;

    let res = client.do_get("/v0/info").await?;
    assert_eq!(res.status(), 200);

    let body = res.json_body()?;
    assert_eq!(body["name"], env!("CARGO_PKG_NAME"));
    assert_eq!(body["version"], env!("CARGO_PKG_VERSION"));

    Ok(())
}

#[tokio::test]
async fn test_profile_endpoint() -> Result<()> {
    let client = httpc_test::new_client(HOST_URL)?;

    // Look for Aldert pk user id
    let user_id = "4snwyct86m383rsduhw5xgcxpw7c63j3pq8x4ycqikxgik8y64ro";
    let res = client.do_get(&format!("/v0/profile/{}", user_id)).await?;
    assert_eq!(res.status(), 200);

    let body = res.json_body()?;
    assert_eq!(body["profile"]["name"], "Aldert");
    assert_eq!(body["profile"]["status"], "working");

    // Look for Aldert pk user id using Flavio's viewer id
    let viewer_id = "5g3fwnue819wfdjwiwm8qr35ww6uxxgbzrigrtdgmbi19ksioeoy";
    let res = client
        .do_get(&format!("/v0/profile/{}?viewer_id={}", user_id, viewer_id))
        .await?;
    assert_eq!(res.status(), 200);

    let body = res.json_body()?;
    assert_eq!(body["viewer"]["followed_by"], true); // Aldert follows Flavio
    assert_eq!(body["viewer"]["following"], false); // Flavio does not follow Alder

    // Look for a non existing pk
    let user_id = "bad_user_id";
    let res = client.do_get(&format!("/v0/profiles/{}", user_id)).await?;
    assert_eq!(res.status(), 404);

    Ok(())
}

#[tokio::test]
async fn test_static_file_serving() -> Result<()> {
    let client = httpc_test::new_client(HOST_URL)?;

    let res = client.do_get("/static/src/main.rs").await?;
    assert_eq!(res.status(), 200);
    let body = res.text_body()?;
    assert!(body.contains("fn main()"));

    Ok(())
}

#[tokio::test]
async fn test_swagger_ui() -> Result<()> {
    let client = httpc_test::new_client(HOST_URL)?;

    let res = client.do_get("/swagger-ui").await?;
    assert_eq!(res.status(), 200);
    let body = res.text_body()?;
    assert!(body.contains("<html"));

    Ok(())
}

#[tokio::test]
async fn test_openapi_schema() -> Result<()> {
    let client = httpc_test::new_client(HOST_URL)?;

    let res = client.do_get("/api-docs/openapi.json").await?;
    assert_eq!(res.status(), 200);

    let body = res.json_body()?;
    assert!(body["openapi"].is_string());
    assert!(body["info"]["title"].is_string());
    assert_eq!(body["info"]["version"], env!("CARGO_PKG_VERSION"));
    assert!(body["paths"].is_object());

    Ok(())
}

// Intended to print out requests and play around as a client while developing
#[tokio::test]
async fn quick_dev() -> Result<()> {
    let hc = httpc_test::new_client(HOST_URL)?;

    // Check endpoint, play with this.
    let user_id = "4snwyct86m383rsduhw5xgcxpw7c63j3pq8x4ycqikxgik8y64ro";
    let viewer_id = "5g3fwnue819wfdjwiwm8qr35ww6uxxgbzrigrtdgmbi19ksioeoy";
    hc.do_get(&format!("/v0/profile/{}?viewer_id={}", user_id, viewer_id))
        .await?
        .print()
        .await?;

    Ok(())
}
```
./service/benches/profile.rs
```
use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};
use pk_social_service::config::Config;
use pk_social_service::models::profile::Profile;
use pk_social_service::setup;
use std::time::Duration;
use tokio::runtime::Runtime;

pub fn run_setup() {
    let rt = Runtime::new().unwrap();
    rt.block_on(async {
        let config = Config::from_env();
        setup::setup(&config).await;
    });
}

fn bench_profile(c: &mut Criterion) {
    run_setup();

    let user_id = "4snwyct86m383rsduhw5xgcxpw7c63j3pq8x4ycqikxgik8y64ro";
    let viewer_id = "5g3fwnue819wfdjwiwm8qr35ww6uxxgbzrigrtdgmbi19ksioeoy"; // Provide the viewer_id
    let rt = Runtime::new().unwrap();

    c.bench_with_input(
        BenchmarkId::new("get_profile_by_id", user_id),
        &user_id,
        |b, &id| {
            b.to_async(&rt).iter(|| async {
                let profile = Profile::get_by_id(id, Some(viewer_id)).await.unwrap();
                criterion::black_box(profile);
            });
        },
    );
}

fn configure_criterion() -> Criterion {
    Criterion::default()
        .measurement_time(Duration::new(5, 0))
        .sample_size(500)
        .warm_up_time(Duration::new(1, 0))
}

criterion_group! {
    name = benches;
    config = configure_criterion();
    targets = bench_profile
}

criterion_main!(benches);
```
./service/Cargo.toml
```
[package]
name = "pk-social-service"
version = "0.1.0"
edition = "2021"
description = "Server that exposes a social-media-like view out of pubky events for pubky-app clients"
homepage = "https://github.com/pubky"
repository = "https://github.com/pubky/pubky-app-backend"
license = "MIT"

[dependencies]
pk-social-common = { path = "../common" }
tokio = { version = "1.38.0", features = ["full"] }
axum = "0.7.5"
serde = { version = "1.0.204", features = ["derive"] }
serde_json = "1.0.120"
utoipa = "4.2.3"
utoipa-swagger-ui = { version = "7.1.0", features = ["axum"] }
tower-http = { version = "0.5.2", features = ["fs"] }
dotenv = "0.15"

[dev-dependencies]
anyhow = "1.0.86"
httpc-test = "0.1.9"
criterion = { version = "0.5.1", features = ["async_tokio"] }

[lib]
name = "pk_social_service"
path = "src/lib.rs"

[[bin]]
name = "pk-social-service"
path = "src/main.rs"

[[bench]]
name = "profile"
harness = false
```
./Cargo.toml
```
[workspace]
members = ["common", "service", "watcher"]

resolver = "2"
```
./common/src/db/mod.rs
```
pub mod neo4j;
```
./common/src/db/neo4j/mod.rs
```
pub mod queries;
```
./common/src/db/neo4j/queries.rs
```
use neo4rs::{query, Query};

// Retrive user node by id (pk)
pub fn get_user_by_id(user_id: &str) -> Query {
    query("MATCH (u:User {id: $id}) RETURN u").param("id", user_id)
}

pub fn get_tagged_as(user_id: &str) -> neo4rs::Query {
    query(
        "MATCH (u:User {id: $id})-[:TAGGED_AS]->(t:Tag)<-[:TAGGED_BY]-(author:User)
           RETURN t.tag AS tag, COUNT(t) AS count, author, COLLECT(author) AS authors",
    )
    .param("id", user_id)
}

pub fn get_follow_counts(user_id: &str) -> neo4rs::Query {
    query(
        "MATCH (u:User {id: $id})
           OPTIONAL MATCH (u)-[:FOLLOWS]->(following:User)
           OPTIONAL MATCH (follower:User)-[:FOLLOWS]->(u)
           OPTIONAL MATCH (u)-[:FOLLOWS]->(friend:User)-[:FOLLOWS]->(u)
           RETURN COUNT(DISTINCT following) AS following_count,
                  COUNT(DISTINCT follower) AS followers_count,
                  COUNT(DISTINCT friend) AS friends_count",
    )
    .param("id", user_id)
}

pub fn viewer_relationship(user_id: &str, viewer_id: &str) -> neo4rs::Query {
    query(
        "MATCH (u:User {id: $user_id})
         OPTIONAL MATCH (viewer:User {id: $viewer_id})-[:FOLLOWS]->(u)
         OPTIONAL MATCH (u)-[:FOLLOWS]->(viewer)
         RETURN COUNT(DISTINCT viewer) > 0 AS following,
                COUNT(DISTINCT u) > 0 AS followed_by",
    )
    .param("user_id", user_id)
    .param("viewer_id", viewer_id)
}

// Combine Profile queries into one (Not yet used)
pub fn _get_user_profile_data(user_id: &str, viewer_id: Option<&str>) -> Query {
    let viewer = viewer_id.unwrap_or("none");
    println!("{viewer}");

    query(
        "
        MATCH (u:User {{id: $id}})
        OPTIONAL MATCH (u)-[:TAGGED_AS]->(t:Tag)<-[:TAGGED_BY]-(author:User)
        OPTIONAL MATCH (u)-[:AUTHORED]->(p:Post)
        OPTIONAL MATCH (u)-[:FOLLOWS]->(following:User)
        OPTIONAL MATCH (follower:User)-[:FOLLOWS]->(u)
        OPTIONAL MATCH (u)-[:FOLLOWS]->(friend:User)-[:FOLLOWS]->(u)
        OPTIONAL MATCH (viewer:User {{id: $viewer_id}})-[f:FOLLOWS]->(u)
        OPTIONAL MATCH (u)-[fb:FOLLOWS]->(viewer)
        RETURN COUNT(f) > 0 AS following, COUNT(fb) > 0 AS followed_by
        RETURN u, COLLECT(DISTINCT t) AS tags, 
               COUNT(DISTINCT p) AS posts_count,
               COUNT(DISTINCT following) AS following_count,
               COUNT(DISTINCT follower) AS followers_count,
               COUNT(DISTINCT friend) AS friends_count,
               false AS following, false AS followed_by
        ",
    )
    .param("id", user_id)
    .param("viewer_id", viewer)
}
```
./common/src/connectors/neo4j.rs
```
pub use neo4rs::{query, Graph, Node};
use once_cell::sync::OnceCell;
use std::fmt;
use std::sync::Arc;
use tokio::sync::Mutex;

pub struct Neo4jConnector {
    pub graph: OnceCell<Arc<Mutex<Graph>>>,
}

impl Default for Neo4jConnector {
    fn default() -> Self {
        Self::new()
    }
}

impl Neo4jConnector {
    pub fn new() -> Self {
        Self {
            graph: OnceCell::new(),
        }
    }

    pub async fn connect(
        &self,
        uri: &str,
        user: &str,
        password: &str,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let graph = Graph::new(uri, user, password).await?;
        self.graph
            .set(Arc::new(Mutex::new(graph)))
            .map_err(|_| "Failed to set graph instance")?;
        Ok(())
    }

    pub async fn new_connection(
        uri: &str,
        user: &str,
        password: &str,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let neo4j_connector = Neo4jConnector::new();
        neo4j_connector.connect(uri, user, password).await?;
        Ok(neo4j_connector)
    }
}

impl fmt::Debug for Neo4jConnector {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Neo4jConnector")
            .field("graph", &"Graph instance")
            .finish()
    }
}

/// Retrieves a Neo4j graph connection.
pub fn get_neo4j_graph() -> Result<Arc<Mutex<Graph>>, &'static str> {
    let neo4j_connector = NEO4J_CONNECTOR
        .get()
        .ok_or("Neo4jConnector not initialized")?;
    let graph = neo4j_connector
        .graph
        .get()
        .ok_or("Not connected to Neo4j")?;
    Ok(graph.clone())
}

pub static NEO4J_CONNECTOR: OnceCell<Neo4jConnector> = OnceCell::new();
```
./common/src/connectors/mod.rs
```
pub mod neo4j;
pub mod redis;
```
./common/src/connectors/redis.rs
```
use once_cell::sync::OnceCell;
use redis::aio::MultiplexedConnection;
pub use redis::AsyncCommands;
use redis::Client;
use std::fmt;

pub struct RedisConnector {
    client: OnceCell<Client>,
}

impl Default for RedisConnector {
    fn default() -> Self {
        Self::new()
    }
}

impl RedisConnector {
    pub fn new() -> Self {
        Self {
            client: OnceCell::new(),
        }
    }

    pub async fn connect(&self, uri: &str) -> Result<(), Box<dyn std::error::Error>> {
        let client = Client::open(uri)?;
        self.client
            .set(client)
            .map_err(|_| "Failed to set Redis client instance")?;
        Ok(())
    }

    pub async fn new_connection(uri: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let redis_connector = RedisConnector::new();
        redis_connector.connect(uri).await?;
        Ok(redis_connector)
    }

    pub fn client(&self) -> &Client {
        self.client.get().expect("Not connected to Redis")
    }
}

impl fmt::Debug for RedisConnector {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("RedisConnector")
            .field("client", &"Redis client instance")
            .finish()
    }
}

/// Retrieves a Redis connection.
pub async fn get_redis_conn() -> Result<MultiplexedConnection, Box<dyn std::error::Error>> {
    let redis_client = REDIS_CONNECTOR
        .get()
        .ok_or("RedisConnector not initialized")?
        .client();
    let redis_conn = redis_client.get_multiplexed_async_connection().await?;
    Ok(redis_conn)
}

pub static REDIS_CONNECTOR: OnceCell<RedisConnector> = OnceCell::new();
```
./common/src/lib.rs
```
mod db;

pub mod connectors;
pub use db::neo4j::queries;
```
./common/Cargo.toml
```
[package]
name = "pk-social-common"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.38.0", features = ["full"] }
neo4rs = "0.7.1"
once_cell = "1.19.0"
redis = { version = "0.25.4", features = ["tokio-comp"] }
```
